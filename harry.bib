@inproceedings{Reynolds74,
  author    = {John C. Reynolds},
  editor    = {Bernard Robinet},
  title     = {Towards a theory of type structure},
  booktitle = {Programming Symposium, Proceedings Colloque sur la Programmation,
               Paris, France, April 9-11, 1974},
  series    = {Lecture Notes in Computer Science},
  volume    = {19},
  pages     = {408--423},
  publisher = {Springer},
  year      = {1974},
  url       = {https://doi.org/10.1007/3-540-06859-7\_148},
  doi       = {10.1007/3-540-06859-7\_148},
  timestamp = {Tue, 14 May 2019 10:00:35 +0200},
  biburl    = {https://dblp.org/rec/conf/programm/Reynolds74.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{Courcelle83,
  author    = {Bruno Courcelle},
  title     = {Fundamental Properties of Infinite Trees},
  journal   = {Theor. Comput. Sci.},
  volume    = {25},
  pages     = {95--169},
  year      = {1983},
  url       = {https://doi.org/10.1016/0304-3975(83)90059-2},
  doi       = {10.1016/0304-3975(83)90059-2},
  timestamp = {Wed, 14 Nov 2018 10:33:29 +0100},
  biburl    = {https://dblp.org/rec/journals/tcs/Courcelle83.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icfp/ClaessenH00,
  author    = {Koen Claessen and
               John Hughes},
  editor    = {Martin Odersky and
               Philip Wadler},
  title     = {QuickCheck: a lightweight tool for random testing of Haskell programs},
  booktitle = {Proceedings of the Fifth {ACM} {SIGPLAN} International Conference
               on Functional Programming {(ICFP} '00), Montreal, Canada, September
               18-21, 2000},
  pages     = {268--279},
  publisher = {{ACM}},
  year      = {2000},
  url       = {https://doi.org/10.1145/351240.351266},
  doi       = {10.1145/351240.351266},
  timestamp = {Tue, 06 Nov 2018 16:59:25 +0100},
  biburl    = {https://dblp.org/rec/conf/icfp/ClaessenH00.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  address   = {Montreal, Canada}
}

@inproceedings{DBLP:conf/pts/LammelS06,
  author    = {Ralf L{\"{a}}mmel and
               Wolfram Schulte},
  editor    = {M. {\"{U}}mit Uyar and
               Ali Y. Duale and
               Mariusz A. Fecko},
  title     = {Controllable Combinatorial Coverage in Grammar-Based Testing},
  booktitle = {Testing of Communicating Systems, 18th {IFIP} {TC6/WG6.1} International
               Conference, TestCom 2006, New York, NY, USA, May 16-18, 2006, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {3964},
  pages     = {19--38},
  publisher = {Springer},
  year      = {2006},
  url       = {https://doi.org/10.1007/11754008\_2},
  doi       = {10.1007/11754008\_2},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/conf/pts/LammelS06.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icst/UsaolaRAR17,
  author    = {Macario Polo Usaola and
               Francisco Ruiz Romero and
               Rosana Rodriguez{-}Bobada Aranda and
               Ignacio Garc{\'{\i}}a Rodr{\'{\i}}guez de Guzm{\'{a}}n},
  title     = {Test Case Generation with Regular Expressions and Combinatorial Techniques},
  booktitle = {2017 {IEEE} International Conference on Software Testing, Verification
               and Validation Workshops, {ICST} Workshops 2017, Tokyo, Japan, March
               13-17, 2017},
  pages     = {189--198},
  publisher = {{IEEE} Computer Society},
  year      = {2017},
  url       = {https://doi.org/10.1109/ICSTW.2017.38},
  doi       = {10.1109/ICSTW.2017.38},
  timestamp = {Wed, 16 Oct 2019 14:14:54 +0200},
  biburl    = {https://dblp.org/rec/conf/icst/UsaolaRAR17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/haskell/RuncimanNL08,
  author    = {Colin Runciman and
               Matthew Naylor and
               Fredrik Lindblad},
  editor    = {Andy Gill},
  title     = {Smallcheck and lazy smallcheck: automatic exhaustive testing for small
               values},
  booktitle = {Proceedings of the 1st {ACM} {SIGPLAN} Symposium on Haskell, Haskell
               2008, Victoria, BC, Canada, 25 September 2008},
  pages     = {37--48},
  publisher = {{ACM}},
  year      = {2008},
  url       = {https://doi.org/10.1145/1411286.1411292},
  doi       = {10.1145/1411286.1411292},
  timestamp = {Tue, 06 Nov 2018 16:58:22 +0100},
  biburl    = {https://dblp.org/rec/conf/haskell/RuncimanNL08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/padl/SerranoH16,
  author    = {Alejandro Serrano and
               Jurriaan Hage},
  editor    = {Marco Gavanelli and
               John H. Reppy},
  title     = {Generic Matching of Tree Regular Expressions over Haskell Data Types},
  booktitle = {Practical Aspects of Declarative Languages - 18th International Symposium,
               {PADL} 2016, St. Petersburg, FL, USA, January 18-19, 2016. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9585},
  pages     = {83--98},
  publisher = {Springer},
  year      = {2016},
  url       = {https://doi.org/10.1007/978-3-319-28228-2\_6},
  doi       = {10.1007/978-3-319-28228-2\_6},
  timestamp = {Tue, 14 May 2019 10:00:42 +0200},
  biburl    = {https://dblp.org/rec/conf/padl/SerranoH16.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icst/SaleckerG12,
  author    = {Elke Salecker and
               Sabine Glesner},
  editor    = {Giuliano Antoniol and
               Antonia Bertolino and
               Yvan Labiche},
  title     = {Combinatorial Interaction Testing for Test Selection in Grammar-Based
               Testing},
  booktitle = {Fifth {IEEE} International Conference on Software Testing, Verification
               and Validation, {ICST} 2012, Montreal, QC, Canada, April 17-21, 2012},
  pages     = {610--619},
  publisher = {{IEEE} Computer Society},
  year      = {2012},
  url       = {https://doi.org/10.1109/ICST.2012.148},
  doi       = {10.1109/ICST.2012.148},
  timestamp = {Wed, 16 Oct 2019 14:14:54 +0200},
  biburl    = {https://dblp.org/rec/conf/icst/SaleckerG12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icst/KuhnHLKL12,
  author    = {D. Richard Kuhn and
               James M. Higdon and
               James Lawrence and
               Raghu Kacker and
               Yu Lei},
  editor    = {Giuliano Antoniol and
               Antonia Bertolino and
               Yvan Labiche},
  title     = {Combinatorial Methods for Event Sequence Testing},
  booktitle = {Fifth {IEEE} International Conference on Software Testing, Verification
               and Validation, {ICST} 2012, Montreal, QC, Canada, April 17-21, 2012},
  pages     = {601--609},
  publisher = {{IEEE} Computer Society},
  year      = {2012},
  url       = {https://doi.org/10.1109/ICST.2012.147},
  doi       = {10.1109/ICST.2012.147},
  timestamp = {Wed, 16 Oct 2019 14:14:54 +0200},
  biburl    = {https://dblp.org/rec/conf/icst/KuhnHLKL12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/forte/MarianiPW04,
  author    = {Leonardo Mariani and
               Mauro Pezz{\`{e}} and
               David Willmor},
  editor    = {Manuel N{\'{u}}{\~{n}}ez and
               Zakaria Maamar and
               Fernando L. Pelayo and
               Key Pousttchi and
               Fernando Rubio},
  title     = {Generation of Integration Tests for Self-Testing Components},
  booktitle = {Applying Formal Methods: Testing, Performance and M/ECommerce, {FORTE}
               2004 Workshops The FormEMC, EPEW, ITM, Toledo, Spain, October 1-2,
               2004},
  series    = {Lecture Notes in Computer Science},
  volume    = {3236},
  pages     = {337--350},
  publisher = {Springer},
  year      = {2004},
  url       = {https://doi.org/10.1007/978-3-540-30233-9\_25},
  doi       = {10.1007/978-3-540-30233-9\_25},
  timestamp = {Tue, 14 May 2019 10:00:50 +0200},
  biburl    = {https://dblp.org/rec/conf/forte/MarianiPW04.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/pacmpl/MajumdarN18,
  author    = {Rupak Majumdar and
               Filip Niksic},
  title     = {Why is random testing effective for partition tolerance bugs?},
  journal   = {{PACMPL}},
  volume    = {2},
  number    = {{POPL}},
  pages     = {46:1--46:24},
  year      = {2018},
  url       = {https://doi.org/10.1145/3158134},
  doi       = {10.1145/3158134},
  timestamp = {Tue, 06 Nov 2018 12:51:05 +0100},
  biburl    = {https://dblp.org/rec/journals/pacmpl/MajumdarN18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/siamdm/SarkarC17,
  author    = {Kaushik Sarkar and
               Charles J. Colbourn},
  title     = {Upper Bounds on the Size of Covering Arrays},
  journal   = {{SIAM} J. Discrete Math.},
  volume    = {31},
  number    = {2},
  pages     = {1277--1293},
  year      = {2017},
  url       = {https://doi.org/10.1137/16M1067767},
  doi       = {10.1137/16M1067767},
  timestamp = {Wed, 05 Jul 2017 14:44:19 +0200},
  biburl    = {https://dblp.org/rec/journals/siamdm/SarkarC17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/asian/ChenLM04,
  author    = {Tsong Yueh Chen and
               Hing Leung and
               I. K. Mak},
  title     = {Adaptive Random Testing},
  booktitle = {Advances in Computer Science - {ASIAN} 2004, Higher-Level Decision
               Making, 9th Asian Computing Science Conference, Dedicated to Jean-Louis
               Lassez on the Occasion of His 5th Cycle Birthday, Chiang Mai, Thailand,
               December 8-10, 2004, Proceedings},
  pages     = {320--329},
  year      = {2004},
  crossref  = {DBLP:conf/asian/2004},
  url       = {https://doi.org/10.1007/978-3-540-30502-6\_23},
  doi       = {10.1007/978-3-540-30502-6\_23},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/conf/asian/ChenLM04.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@proceedings{DBLP:conf/asian/2004,
  editor    = {Michael J. Maher},
  title     = {Advances in Computer Science - {ASIAN} 2004, Higher-Level Decision
               Making, 9th Asian Computing Science Conference, Dedicated to Jean-Louis
               Lassez on the Occasion of His 5th Cycle Birthday, Chiang Mai, Thailand,
               December 8-10, 2004, Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {3321},
  publisher = {Springer},
  year      = {2004},
  url       = {https://doi.org/10.1007/b103476},
  doi       = {10.1007/b103476},
  isbn      = {3-540-24087-X},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/conf/asian/2004.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icse/CiupaLOM08,
  author    = {Ilinca Ciupa and
               Andreas Leitner and
               Manuel Oriol and
               Bertrand Meyer},
  title     = {{ARTOO:} adaptive random testing for object-oriented software},
  booktitle = {30th International Conference on Software Engineering {(ICSE} 2008),
               Leipzig, Germany, May 10-18, 2008},
  pages     = {71--80},
  year      = {2008},
  crossref  = {DBLP:conf/icse/2008},
  url       = {https://doi.org/10.1145/1368088.1368099},
  doi       = {10.1145/1368088.1368099},
  timestamp = {Wed, 14 Nov 2018 10:57:08 +0100},
  biburl    = {https://dblp.org/rec/conf/icse/CiupaLOM08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@proceedings{DBLP:conf/icse/2008,
  editor    = {Wilhelm Sch{\"{a}}fer and
               Matthew B. Dwyer and
               Volker Gruhn},
  title     = {30th International Conference on Software Engineering {(ICSE} 2008),
               Leipzig, Germany, May 10-18, 2008},
  publisher = {{ACM}},
  year      = {2008},
  isbn      = {978-1-60558-079-1},
  timestamp = {Tue, 23 Sep 2008 09:00:49 +0200},
  biburl    = {https://dblp.org/rec/conf/icse/2008.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/issta/ArcuriB11,
  author    = {Andrea Arcuri and
               Lionel C. Briand},
  title     = {Adaptive random testing: an illusion of effectiveness?},
  booktitle = {Proceedings of the 20th International Symposium on Software Testing
               and Analysis, {ISSTA} 2011, Toronto, ON, Canada, July 17-21, 2011},
  pages     = {265--275},
  year      = {2011},
  crossref  = {DBLP:conf/issta/2011},
  url       = {https://doi.org/10.1145/2001420.2001452},
  doi       = {10.1145/2001420.2001452},
  timestamp = {Tue, 06 Nov 2018 16:57:30 +0100},
  biburl    = {https://dblp.org/rec/conf/issta/ArcuriB11.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@proceedings{DBLP:conf/issta/2011,
  editor    = {Matthew B. Dwyer and
               Frank Tip},
  title     = {Proceedings of the 20th International Symposium on Software Testing
               and Analysis, {ISSTA} 2011, Toronto, ON, Canada, July 17-21, 2011},
  publisher = {{ACM}},
  year      = {2011},
  url       = {https://doi.org/10.1145/2001420},
  doi       = {10.1145/2001420},
  isbn      = {978-1-4503-0562-4},
  timestamp = {Tue, 06 Nov 2018 16:57:30 +0100},
  biburl    = {https://dblp.org/rec/conf/issta/2011.bib}
}

@inproceedings{DBLP:conf/haskell/GillR07,
  author    = {Andy Gill and
               Colin Runciman},
  editor    = {Gabriele Keller},
  title     = {Haskell program coverage},
  booktitle = {Proceedings of the {ACM} {SIGPLAN} Workshop on Haskell, Haskell 2007,
               Freiburg, Germany, September 30, 2007},
  pages     = {1--12},
  publisher = {{ACM}},
  year      = {2007},
  url       = {https://doi.org/10.1145/1291201.1291203},
  doi       = {10.1145/1291201.1291203},
  timestamp = {Tue, 06 Nov 2018 16:58:22 +0100},
  biburl    = {https://dblp.org/rec/conf/haskell/GillR07.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/haskell/MistaRH18,
  author    = {Agust{\'{\i}}n Mista and
               Alejandro Russo and
               John Hughes},
  editor    = {Nicolas Wu},
  title     = {Branching processes for QuickCheck generators},
  booktitle = {Proceedings of the 11th {ACM} {SIGPLAN} International Symposium on
               Haskell, Haskell@ICFP 2018, St. Louis, MO, USA, September 27-17, 2018},
  pages     = {1--13},
  publisher = {{ACM}},
  year      = {2018},
  url       = {https://doi.org/10.1145/3242744.3242747},
  doi       = {10.1145/3242744.3242747},
  timestamp = {Tue, 11 Dec 2018 19:30:58 +0100},
  biburl    = {https://dblp.org/rec/conf/haskell/MistaRH18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/isci/Torres-JimenezR12,
  author    = {Jose Torres{-}Jimenez and
               Eduardo Rodriguez{-}Tello},
  title     = {New bounds for binary covering arrays using simulated annealing},
  journal   = {Inf. Sci.},
  volume    = {185},
  number    = {1},
  pages     = {137--152},
  year      = {2012},
  url       = {https://doi.org/10.1016/j.ins.2011.09.020},
  doi       = {10.1016/j.ins.2011.09.020},
  timestamp = {Tue, 06 Jun 2017 22:27:26 +0200},
  biburl    = {https://dblp.org/rec/journals/isci/Torres-JimenezR12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/iastedSE/ColbournCT04,
  author    = {Charles J. Colbourn and
               Myra B. Cohen and
               Ren{\'{e}}e Turban},
  editor    = {M. H. Hamza},
  title     = {A deterministic density algorithm for pairwise interaction coverage},
  booktitle = {{IASTED} International Conference on Software Engineering, part of
               the 22nd Multi-Conference on Applied Informatics, Innsbruck, Austria,
               February 17-19, 2004},
  pages     = {345--352},
  publisher = {{IASTED/ACTA} Press},
  year      = {2004},
  timestamp = {Wed, 08 Nov 2006 11:22:27 +0100},
  biburl    = {https://dblp.org/rec/conf/iastedSE/ColbournCT04.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

% Couldn't find better BibTeX entries...

@inproceedings{bach2004pairwise,
  title        = {Pairwise testing: A best practice that isn't},
  author       = {Bach, James and Schroeder, Patrick J},
  booktitle    = {Proceedings of 22nd Pacific Northwest Software Quality Conference},
  pages        = {180--196},
  year         = {2004},
  organization = {Citeseer}
}

@article{kuhn2010practical,
  title   = {Practical combinatorial testing},
  author  = {Kuhn, D Richard and Kacker, Raghu N and Lei, Yu},
  journal = {NIST special Publication},
  volume  = {800},
  number  = {142},
  pages   = {142},
  year    = {2010}
}

@misc{tata2007,
  author       = {H. Comon and M. Dauchet and R. Gilleron and  C. L\"oding
                  and F. Jacquemard
                  and D. Lugiez and S. Tison and M. Tommasi},
  title        = {Tree Automata Techniques and Applications},
  howpublished = {Available on: \url{http://www.grappa.univ-lille3.fr/tata}},
  note         = {release October, 12th 2007},
  year         = 2007
}

@article{CombinatorialTestingSurvey,
  author     = {Nie, Changhai and Leung, Hareton},
  title      = {A Survey of Combinatorial Testing},
  year       = {2011},
  issue_date = {January 2011},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {43},
  number     = {2},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/1883612.1883618},
  doi        = {10.1145/1883612.1883618},
  journal    = {ACM Comput. Surv.},
  month      = feb,
  articleno  = {Article 11},
  numpages   = {29},
  keywords   = {Software testing, covering array, test case generation, combinatorial testing (CT)}
}

@misc{wu2019survey,
  title         = {A Survey of Constrained Combinatorial Testing},
  author        = {Huayao Wu and Changhai Nie and Justyna Petke and Yue Jia and Mark Harman},
  year          = {2019},
  eprint        = {1908.02480},
  archiveprefix = {arXiv},
  primaryclass  = {cs.SE}
}

@inproceedings{PalkaAST11,
  author         = {Pa{\l}ka, Micha{\l} H. and Claessen, Koen and Russo, Alejandro and Hughes, John},
  title          = {Testing an Optimising Compiler by Generating Random Lambda Terms},
  booktitle      = {Proceedings of the 6th International Workshop on Automation of Software Test},
  shortbooktitle = {AST},
  series         = {AST '11},
  year           = {2011},
  isbn           = {978-1-4503-0592-1},
  location       = {Waikiki, Honolulu, HI, USA},
  pages          = {91--97},
  numpages       = {7},
  url            = {http://doi.acm.org/10.1145/1982595.1982615},
  doi            = {10.1145/1982595.1982615},
  acmid          = {1982615},
  publisher      = {ACM},
  address        = {New York, NY, USA},
  keywords       = {random testing, software testing}
}

@article{ClaessenDP15,
  author    = {Koen Claessen and
               Jonas Dureg{\aa}rd and
               Michal H. Palka},
  title     = {Generating constrained random data with uniform distribution},
  journal   = {J. Funct. Program.},
  volume    = {25},
  year      = {2015},
  url       = {http://dx.doi.org/10.1017/S0956796815000143},
  doi       = {10.1017/S0956796815000143},
  timestamp = {Tue, 26 Jan 2016 16:08:20 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/jfp/ClaessenDP15},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{LuckPOPL,
  author    = {Leonidas Lampropoulos and
               Diane Gallois{-}Wong and
               Catalin Hritcu and
               John Hughes and
               Benjamin C. Pierce and
               Li{-}yao Xia},
  title     = {Beginner's {Luck}: a language for property-based generators},
  booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of
               Programming Languages, {POPL} 2017, Paris, France, January 18-20,
               2017},
  pages     = {114--129},
  year      = {2017},
  url       = {http://dl.acm.org/citation.cfm?id=3009868},
  timestamp = {Wed, 28 Dec 2016 13:22:29 +0100},
  biburl    = {http://dblp2.uni-trier.de/rec/bib/conf/popl/LampropoulosGHH17},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{YangCER11,
  author         = {Xuejun Yang and
                    Yang Chen and
                    Eric Eide and
                    John Regehr},
  title          = {Finding and understanding bugs in {C} compilers},
  booktitle      = {Proceedings of the 32nd {ACM} {SIGPLAN} Conference on Programming
                    Language Design and Implementation, {PLDI} 2011, San Jose, CA, USA,
                    June 4-8, 2011},
  shortbooktitle = {PLDI},
  pages          = {283--294},
  year           = {2011},
  ee             = {http://doi.acm.org/10.1145/1993498.1993532},
  doi            = {10.1145/1993498.1993532},
  timestamp      = {Tue, 07 Jun 2011 16:07:38 +0200},
  biburl         = {http://dblp.uni-trier.de/rec/bib/conf/pldi/YangCER11},
  bibsource      = {dblp computer science bibliography, http://dblp.org},
  url            = {http://www.cs.utah.edu/~regehr/papers/pldi11-preprint.pdf}
}

@inproceedings{RegehrCCEEY12,
  author         = {John Regehr and
                    Yang Chen and
                    Pascal Cuoq and
                    Eric Eide and
                    Chucky Ellison and
                    Xuejun Yang},
  title          = {Test-case reduction for {C} compiler bugs},
  booktitle      = {{ACM} {SIGPLAN} Conference on Programming Language Design and Implementation,
                    {PLDI} '12, Beijing, China - June 11 - 16, 2012},
  shortbooktitle = {PLDI},
  pages          = {335--346},
  year           = {2012},
  ee             = {http://doi.acm.org/10.1145/2254064.2254104},
  doi            = {10.1145/2254064.2254104},
  timestamp      = {Tue, 12 Jun 2012 20:04:16 +0200},
  biburl         = {http://dblp.uni-trier.de/rec/bib/conf/pldi/RegehrCCEEY12},
  bibsource      = {dblp computer science bibliography, http://dblp.org},
  url            = {http://www.cs.utah.edu/~regehr/papers/pldi12-preprint.pdf}
}

@article{HowToSpecifyIt,
  author  = {John Hughes},
  title   = {How to Specify It!},
  journal = {20th International Symposium on Trends in Functional Programming},
  year    = {2019}
}

@inproceedings{bell2005effectiveness,
  title        = {On effectiveness of pairwise methodology for testing network-centric software},
  author       = {Bell, Kera Z and Vouk, Mladen A},
  booktitle    = {2005 International Conference on Information and Communication Technology},
  pages        = {221--235},
  year         = {2005},
  organization = {IEEE}
}

@article{kuhn2004software,
  title     = {Software fault interactions and implications for software testing},
  author    = {Kuhn, D Richard and Wallace, Dolores R and Gallo, Albert M},
  journal   = {IEEE transactions on software engineering},
  volume    = {30},
  number    = {6},
  pages     = {418--421},
  year      = {2004},
  publisher = {IEEE}
}

@inproceedings{lei2007ipog,
  title        = {IPOG: A general strategy for t-way software testing},
  author       = {Lei, Yu and Kacker, Raghu and Kuhn, D Richard and Okun, Vadim and Lawrence, James},
  booktitle    = {14th Annual IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS'07)},
  pages        = {549--556},
  year         = {2007},
  organization = {IEEE}
}

@phdthesis{girard1972interpretation,
  title  = {Interpr{\'e}tation fonctionnelle et {\'e}limination des coupures de l'arithm{\'e}tique d'ordre sup{\'e}rieur},
  author = {Girard, Jean-Yves},
  year   = {1972},
  school = {{\'E}diteur inconnu}
}

@inproceedings{luo2014empirical,
  title     = {An empirical analysis of flaky tests},
  author    = {Luo, Qingzhou and Hariri, Farah and Eloussi, Lamyaa and Marinov, Darko},
  booktitle = {Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  pages     = {643--653},
  year      = {2014}
}

@incollection{CUSTOM:book/aosa/MarlowPJ12,
  author    = {Simon Marlow and Simon Peyton-Jones},
  title     = {The {Glasgow} {Haskell} {Compiler}},
  editor    = {Amy Brown and Greg Wilson},
  booktitle = {The Architecture of Open Source Applications},
  volume    = {II},
  url       = {http://www.aosabook.org/en/ghc.html},
  publisher = {Available online under the {Creative Commons Attribution 3.0
               Unported} license},
  year      = {2012},
  month     = {March},
  day       = {30}
}

@misc{afl-readme,
  author       = {Michal Zalewski},
  title        = {{AFL} quick start guide},
  howpublished = {\url{http://lcamtuf.coredump.cx/afl/QuickStartGuide.txt}},
  month        = apr,
  year         = 2018
}

@article{NASA-GSFC,
  author  = {D. R. {Kuhn} and D. R. {Wallace} and A. M. {Gallo}},
  journal = {IEEE Transactions on Software Engineering},
  title   = {Software fault interactions and implications for software testing},
  year    = {2004},
  volume  = {30},
  number  = {6},
  pages   = {418-421},
  doi     = {10.1109/TSE.2004.24}
}

@inproceedings{DBLP:conf/issta/MathisGZ20,
  author    = {Bj{\"{o}}rn Mathis and
               Rahul Gopinath and
               Andreas Zeller},
  editor    = {Sarfraz Khurshid and
               Corina S. Pasareanu},
  title     = {Learning input tokens for effective fuzzing},
  booktitle = {{ISSTA} '20: 29th {ACM} {SIGSOFT} International Symposium on Software
               Testing and Analysis, Virtual Event, USA, July 18-22, 2020},
  pages     = {27--37},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3395363.3397348},
  doi       = {10.1145/3395363.3397348},
  timestamp = {Wed, 15 Jul 2020 16:06:56 +0200},
  biburl    = {https://dblp.org/rec/conf/issta/MathisGZ20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/kbse/HavrikovZ19,
  author    = {Nikolas Havrikov and
               Andreas Zeller},
  title     = {Systematically Covering Input Structure},
  booktitle = {34th {IEEE/ACM} International Conference on Automated Software Engineering,
               {ASE} 2019, San Diego, CA, USA, November 11-15, 2019},
  pages     = {189--199},
  publisher = {{IEEE}},
  year      = {2019},
  url       = {https://doi.org/10.1109/ASE.2019.00027},
  doi       = {10.1109/ASE.2019.00027},
  timestamp = {Sun, 19 Jan 2020 15:19:48 +0100},
  biburl    = {https://dblp.org/rec/conf/kbse/HavrikovZ19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icse/ReddyLPS20,
  author    = {Sameer Reddy and
               Caroline Lemieux and
               Rohan Padhye and
               Koushik Sen},
  editor    = {Gregg Rothermel and
               Doo{-}Hwan Bae},
  title     = {Quickly generating diverse valid test inputs with reinforcement learning},
  booktitle = {{ICSE} '20: 42nd International Conference on Software Engineering,
               Seoul, South Korea, 27 June - 19 July, 2020},
  pages     = {1410--1421},
  publisher = {{ACM}},
  year      = {2020},
  url       = {https://doi.org/10.1145/3377811.3380399},
  doi       = {10.1145/3377811.3380399},
  timestamp = {Fri, 08 Jan 2021 14:47:26 +0100},
  biburl    = {https://dblp.org/rec/conf/icse/ReddyLPS20.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/pacmpl/PadhyeLSSV19,
  author    = {Rohan Padhye and
               Caroline Lemieux and
               Koushik Sen and
               Laurent Simon and
               Hayawardh Vijayakumar},
  title     = {FuzzFactory: domain-specific fuzzing with waypoints},
  journal   = {Proc. {ACM} Program. Lang.},
  volume    = {3},
  number    = {{OOPSLA}},
  pages     = {174:1--174:29},
  year      = {2019},
  url       = {https://doi.org/10.1145/3360600},
  doi       = {10.1145/3360600},
  timestamp = {Thu, 16 Apr 2020 13:51:49 +0200},
  biburl    = {https://dblp.org/rec/journals/pacmpl/PadhyeLSSV19.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@incollection{fuzzingbook2019:index,
  author       = {Andreas Zeller and Rahul Gopinath and Marcel B{\"o}hme and Gordon Fraser and Christian Holler},
  booktitle    = {The Fuzzing Book},
  title        = {The Fuzzing Book},
  year         = {2019},
  publisher    = {Saarland University},
  howpublished = {\url{https://www.fuzzingbook.org/}},
  note         = {Retrieved 2019-09-09 16:42:54+02:00},
  url          = {https://www.fuzzingbook.org/},
  urldate      = {2019-09-09 16:42:54+02:00}
}

@inproceedings{stephens2016driller,
  title     = {Driller: Augmenting Fuzzing Through Selective Symbolic Execution.},
  author    = {Stephens, Nick and Grosen, John and Salls, Christopher and Dutcher, Andrew and Wang, Ruoyu and Corbetta, Jacopo and Shoshitaishvili, Yan and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {Network and Distributed System Security Symposium (NDSS)},
  year      = {2016}
}

@inproceedings{217563,
  author    = {Insu Yun and Sangho Lee and Meng Xu and Yeongjin Jang and Taesoo Kim},
  title     = {{QSYM} : A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing},
  booktitle = {27th {USENIX} Security Symposium ({USENIX} Security 18)},
  year      = {2018},
  isbn      = {978-1-931971-46-1},
  address   = {Baltimore, MD},
  pages     = {745--761},
  url       = {https://www.usenix.org/conference/usenixsecurity18/presentation/yun},
  publisher = {{USENIX} Association}
}

@article{livinskii2020random,
  title     = {Random testing for C and C++ compilers with YARPGen},
  author    = {Livinskii, Vsevolod and Babokin, Dmitry and Regehr, John},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {4},
  number    = {OOPSLA},
  pages     = {1--25},
  year      = {2020},
  publisher = {ACM New York, NY, USA}
}

@unpublished{leancheck,
  month     = {October},
  title     = {Tools for Discovery, Refinement and Generalization of Functional Properties by Enumerative Testing},
  school    = {University of York},
  author    = {Rudy Matela Braquehais},
  publisher = {University of York},
  year      = {2017},
  url       = {http://etheses.whiterose.ac.uk/19178/},
  abstract  = {This thesis presents techniques for discovery, refinement and generalization of properties about functional programs.  These techniques work by reasoning from test results: their results are surprisingly accurate in practice, despite an inherent uncertainty in principle.  These techniques are validated by corresponding implementations in Haskell and for Haskell programs: Speculate, FitSpec and Extrapolate.  Speculate discovers properties given a collection of black-box function signatures.  Properties discovered by Speculate include inequalities and conditional equations.  These properties can contribute to program understanding, documentation and regression testing.  FitSpec guides refinements of properties based on results of black-box mutation testing.  These refinements include completion and minimization of property sets.  Extrapolate generalizes counterexamples of test properties.  Generalized counterexamples include repeated variables and side-conditions and can inform the programmer what characterizes failures.  Several example applications demonstrate the effectiveness of Speculate, FitSpec and Extrapolate.}
}

@inproceedings{DBLP:conf/oopsla/KurajKJ15,
  author    = {Ivan Kuraj and
               Viktor Kuncak and
               Daniel Jackson},
  editor    = {Jonathan Aldrich and
               Patrick Eugster},
  title     = {Programming with enumerable sets of structures},
  booktitle = {Proceedings of the 2015 {ACM} {SIGPLAN} International Conference on
               Object-Oriented Programming, Systems, Languages, and Applications,
               {OOPSLA} 2015, part of {SPLASH} 2015, Pittsburgh, PA, USA, October
               25-30, 2015},
  pages     = {37--56},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2814270.2814323},
  doi       = {10.1145/2814270.2814323},
  timestamp = {Tue, 06 Nov 2018 16:57:16 +0100},
  biburl    = {https://dblp.org/rec/conf/oopsla/KurajKJ15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{soremekun2020inputs,
  title     = {Inputs from Hell Learning Input Distributions for Grammar-Based Test Generation},
  author    = {Soremekun, Ezekiel and Pavese, Esteban and Havrikov, Nikolas and Grunske, Lars and Zeller, Andreas},
  journal   = {IEEE Transactions on Software Engineering},
  year      = {2020},
  publisher = {IEEE}
}

@article{rendel2010invertible,
  title     = {Invertible syntax descriptions: unifying parsing and pretty printing},
  author    = {Rendel, Tillmann and Ostermann, Klaus},
  journal   = {ACM Sigplan Notices},
  volume    = {45},
  number    = {11},
  pages     = {1--12},
  year      = {2010},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{xia2019composing,
  title        = {Composing bidirectional programs monadically},
  author       = {Xia, Li-yao and Orchard, Dominic and Wang, Meng},
  booktitle    = {European Symposium on Programming},
  pages        = {147--175},
  year         = {2019},
  organization = {Springer}
}

@phdthesis{foster2009bidirectional,
  title  = {Bidirectional programming languages},
  author = {Foster, John Nathan},
  year   = {2009},
  school = {University of Pennsylvania}
}

@article{leijen2001parsec,
  title  = {Parsec: Direct style monadic parser combinators for the real world},
  author = {Leijen, Daan and Meijer, Erik},
  year   = {2001}
}

@article{bavishi2019autopandas,
  title     = {AutoPandas: neural-backed generators for program synthesis},
  author    = {Bavishi, Rohan and Lemieux, Caroline and Fox, Roy and Sen, Koushik and Stoica, Ion},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {3},
  number    = {OOPSLA},
  pages     = {1--27},
  year      = {2019},
  publisher = {ACM New York, NY, USA}
}

@article{lampropoulos2017generating,
  title     = {Generating good generators for inductive relations},
  author    = {Lampropoulos, Leonidas and Paraskevopoulou, Zoe and Pierce, Benjamin C},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {2},
  number    = {POPL},
  pages     = {1--30},
  year      = {2017},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{godefroid2017learn,
  title        = {Learn\&fuzz: Machine learning for input fuzzing},
  author       = {Godefroid, Patrice and Peleg, Hila and Singh, Rishabh},
  booktitle    = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages        = {50--59},
  year         = {2017},
  organization = {IEEE}
}

@inproceedings{hughes2007quickcheck,
  title        = {QuickCheck testing for fun and profit},
  author       = {Hughes, John},
  booktitle    = {International Symposium on Practical Aspects of Declarative Languages},
  pages        = {1--32},
  year         = {2007},
  organization = {Springer}
}

@inproceedings{arts2006testing,
  title     = {Testing telecoms software with Quviq QuickCheck},
  author    = {Arts, Thomas and Hughes, John and Johansson, Joakim and Wiger, Ulf},
  booktitle = {Proceedings of the 2006 ACM SIGPLAN Workshop on Erlang},
  pages     = {2--10},
  year      = {2006}
}

@misc{MyYouTube,
  title        = {YouTube},
  howpublished = {\url{https://www.youtube.com/channel/UCcc1UtCXkMfmkKnjjFIC7Zg/videos}},
  note         = {Accessed: 2021-09-12},
  year         = {2021}
}

@inproceedings{goldstein2021dojudgeatest,
  author    = {Goldstein, Harrison
               and Hughes, John
               and Lampropoulos, Leonidas
               and Pierce, Benjamin C.},
  title     = {Do Judge a Test by its Cover},
  booktitle = {Programming Languages and Systems: 30th European Symposium on
               Programming, ESOP 2021, Part of the European Joint
               Conferences on Theory and Practice of Software, ETAPS 2021,
               Luxembourg City, Luxembourg, March 27 – April 1, 2021},
  year      = {2021},
  series    = {Lecture Notes in Computer Science},
  volume    = {12648},
  pages     = {264--291},
  isbn      = {978-3-030-72019-3},
  url       = {https://link.springer.com/chapter/10.1007\%2F978-3-030-72019-3_10}
}

@article{brzozowski1964derivatives,
  title     = {Derivatives of regular expressions},
  author    = {Brzozowski, Janusz A},
  journal   = {Journal of the ACM (JACM)},
  volume    = {11},
  number    = {4},
  pages     = {481--494},
  year      = {1964},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{darragh2021clotho,
  title     = {Clotho: A Racket Library for Parametric Randomness},
  author    = {Darragh, Pierce and Hatch, William Gallard and Eide, Eric},
  booktitle = {Functional Programming Workshop},
  pages     = {3},
  year      = {2021}
}

@inproceedings{goldstein2021ungenerators,
  title     = {Ungenerators},
  author    = {Goldstein, Harrison},
  booktitle = {ICFP Student Research Competition},
  year      = {2021},
  url       = {https://harrisongoldste.in/papers/icfpsrc21.pdf}
}

@article{mcbride2008applicative,
  title     = {Applicative programming with effects},
  author    = {McBride, Conor and Paterson, Ross},
  journal   = {Journal of functional programming},
  volume    = {18},
  number    = {1},
  pages     = {1--13},
  year      = {2008},
  publisher = {Cambridge University Press}
}

@article{capriotti2014free,
  title   = {Free applicative functors},
  author  = {Capriotti, Paolo and Kaposi, Ambrus},
  journal = {arXiv preprint arXiv:1403.0749},
  year    = {2014}
}

@inproceedings{levenshtein1966binary,
  title        = {Binary codes capable of correcting deletions, insertions, and reversals},
  author       = {Levenshtein, Vladimir I and others},
  booktitle    = {Soviet physics doklady},
  volume       = {10},
  number       = {8},
  pages        = {707--710},
  year         = {1966},
  organization = {Soviet Union}
}

@article{maciver2019hypothesis,
  title   = {Hypothesis: A new approach to property-based testing},
  author  = {MacIver, David R and Hatfield-Dodds, Zac and others},
  journal = {Journal of Open Source Software},
  volume  = {4},
  number  = {43},
  pages   = {1891},
  year    = {2019}
}

@inproceedings{dolan2017testing,
  title     = {Testing with crowbar},
  author    = {Dolan, Stephen and Preston, Mindy},
  booktitle = {OCaml Workshop},
  year      = {2017}
}

@inproceedings{loscher2017targetedpbt,
  author    = {L\"{o}scher, Andreas and Sagonas, Konstantinos},
  title     = {Targeted Property-Based Testing},
  year      = {2017},
  isbn      = {9781450350761},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3092703.3092711},
  doi       = {10.1145/3092703.3092711},
  booktitle = {Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {46–56},
  numpages  = {11},
  keywords  = {Search-based testing, Property-based testing, PropEr, QuickCheck},
  location  = {Santa Barbara, CA, USA},
  series    = {ISSTA 2017}
}

@article{padhye2019fuzzfactory,
  author     = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik and Simon, Laurent and Vijayakumar, Hayawardh},
  title      = {FuzzFactory: Domain-Specific Fuzzing with Waypoints},
  year       = {2019},
  issue_date = {October 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {OOPSLA},
  url        = {https://doi.org/10.1145/3360600},
  doi        = {10.1145/3360600},
  journal    = {Proc. ACM Program. Lang.},
  month      = {oct},
  articleno  = {174},
  numpages   = {29},
  keywords   = {domain-specific fuzzing, frameworks, fuzz testing, waypoints}
}

@inproceedings{mista2021mutagen,
  title        = {MUTAGEN: Faster Mutation-Based Random Testing},
  author       = {Mista, Agust{\'\i}n},
  booktitle    = {2021 IEEE/ACM 43rd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)},
  pages        = {120--122},
  year         = {2021},
  organization = {IEEE}
}

@inproceedings{padhye2019semantic,
  title     = {Semantic fuzzing with zest},
  author    = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik and Papadakis, Mike and Le Traon, Yves},
  booktitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {329--340},
  year      = {2019}
}

@inproceedings{mista2019deriving,
  title     = {Deriving compositional random generators},
  author    = {Mista, Agust{\'\i}n and Russo, Alejandro},
  booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
  pages     = {1--12},
  year      = {2019}
}

@incollection{kiselyov2012typed,
  title     = {Typed tagless final interpreters},
  author    = {Kiselyov, Oleg},
  booktitle = {Generic and Indexed Programming},
  pages     = {130--174},
  year      = {2012},
  publisher = {Springer}
}

@article{flippr,
  title     = {FliPpr: A System for Deriving Parsers from Pretty-Printers},
  abstract  = {When implementing a programming language, we often write a parser and a pretty-printer. However, manually writing both programs is not only tedious but also error-prone; it may happen that a pretty-printed result is not correctly parsed. In this paper, we propose FliPpr, which is a program transformation system that uses program inversion to produce a CFG parser from a pretty-printer. This novel approach has the advantages of fine-grained control over pretty-printing, and easy reuse of existing efficient pretty-printer and parser implementations.},
  keywords  = {Domain specific language, Language design, Parsing, Pretty-printing, Program inversion, Program transformation},
  author    = {Kazutaka Matsuda and Meng Wang},
  year      = {2018},
  doi       = {10.1007/s00354-018-0033-7},
  language  = {English},
  volume    = {36},
  pages     = {173--202},
  journal   = {New Generation Computing},
  issn      = {0288-3635},
  publisher = {Springer Verlag},
  number    = {3}
}

@inproceedings{10.1145/3092703.3092711,
  author    = {L\"{o}scher, Andreas and Sagonas, Konstantinos},
  title     = {Targeted Property-Based Testing},
  year      = {2017},
  isbn      = {9781450350761},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3092703.3092711},
  doi       = {10.1145/3092703.3092711},
  abstract  = { We introduce targeted property-based testing, an enhanced form of property-based testing that aims to make the input generation component of a property-based testing tool guided by a search strategy rather than being completely random. Thus, this testing technique combines the advantages of both search-based and property-based testing. We demonstrate the technique with the framework we have built, called Target, and show its effectiveness on three case studies. The first of them demonstrates how Target can employ simulated annealing to generate sensor network topologies that form configurations with high energy consumption. The second case study shows how the generation of routing trees for a wireless network equipped with directional antennas can be guided to fulfill different energy metrics. The third case study employs Target to test the noninterference property of information-flow control abstract machine designs, and compares it with a sophisticated hand-written generator for programs of these abstract machines. },
  booktitle = {Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {46–56},
  numpages  = {11},
  keywords  = {Property-based testing, PropEr, Search-based testing, QuickCheck},
  location  = {Santa Barbara, CA, USA},
  series    = {ISSTA 2017}
}

@inproceedings{10.1145/3133956.3134020,
  author    = {B\"{o}hme, Marcel and Pham, Van-Thuan and Nguyen, Manh-Dung and Roychoudhury, Abhik},
  title     = {Directed Greybox Fuzzing},
  year      = {2017},
  isbn      = {9781450349468},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3133956.3134020},
  doi       = {10.1145/3133956.3134020},
  abstract  = {Existing Greybox Fuzzers (GF) cannot be effectively directed, for instance, towards problematic changes or patches, towards critical system calls or dangerous locations, or towards functions in the stack-trace of a reported vulnerability that we wish to reproduce. In this paper, we introduce Directed Greybox Fuzzing (DGF) which generates inputs with the objective of reaching a given set of target program locations efficiently. We develop and evaluate a simulated annealing-based power schedule that gradually assigns more energy to seeds that are closer to the target locations while reducing energy for seeds that are further away. Experiments with our implementation AFLGo demonstrate that DGF outperforms both directed symbolic-execution-based whitebox fuzzing and undirected greybox fuzzing. We show applications of DGF to patch testing and crash reproduction, and discuss the integration of AFLGo into Google's continuous fuzzing platform OSS-Fuzz. Due to its directedness, AFLGo could find 39 bugs in several well-fuzzed, security-critical projects like LibXML2. 17 CVEs were assigned.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2329–2344},
  numpages  = {16},
  keywords  = {directed testing, reachability, crash reproduction, patch testing, verifying true positives, coverage-based greybox fuzzing},
  location  = {Dallas, Texas, USA},
  series    = {CCS '17}
}

@inproceedings{10.1145/1863523.1863525,
  author    = {Rendel, Tillmann and Ostermann, Klaus},
  title     = {Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing},
  year      = {2010},
  isbn      = {9781450302524},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1863523.1863525},
  doi       = {10.1145/1863523.1863525},
  abstract  = {Parsers and pretty-printers for a language are often quite similar, yet both are typically implemented separately, leading to redundancy and potential inconsistency. We propose a new interface of syntactic descriptions, with which both parser and pretty-printer can be described as a single program. Whether a syntactic description is used as a parser or as a pretty-printer is determined by the implementation of the interface. Syntactic descriptions enable programmers to describe the connection between concrete and abstract syntax once and for all, and use these descriptions for parsing or pretty-printing as needed. We also discuss the generalization of our programming technique towards an algebra of partial isomorphisms.},
  booktitle = {Proceedings of the Third ACM Haskell Symposium on Haskell},
  pages     = {1–12},
  numpages  = {12},
  keywords  = {parser combinators, embedded domain specific languages, pretty printing, invertible computation},
  location  = {Baltimore, Maryland, USA},
  series    = {Haskell '10}
}

@article{kennedy2004functional,
  author    = {Kennedy, Andrew},
  title     = {Functional Pearl: Pickler Combinators},
  year      = {2004},
  month     = {January},
  abstract  = {The tedium of writing pickling and unpickling functions by hand is relieved using a combinator library similar in spirit to the well-known parser combinators. Picklers for primitive types are combined to support tupling, alternation, recursion, and structure sharing. Code is presented in Haskell; an alternative implementation in ML is discussed.},
  publisher = {CUP},
  url       = {https://www.microsoft.com/en-us/research/publication/functional-pearl-pickler-combinators/},
  pages     = {727-739},
  journal   = {Journal of Functional Programming},
  volume    = {14},
  edition   = {Journal of Functional Programming}
}

@article{algeffects,
  author  = {Plotkin, Gordon and Power, John},
  year    = {2003},
  month   = {02},
  pages   = {69-94},
  title   = {Algebraic Operations and Generic Effects},
  volume  = {11},
  journal = {Applied Categorical Structures},
  doi     = {10.1023/A:1023064908962}
}

@inproceedings{10.1007/978-3-642-00590-9_7,
  author    = {Plotkin, Gordon
               and Pretnar, Matija},
  editor    = {Castagna, Giuseppe},
  title     = {Handlers of Algebraic Effects},
  booktitle = {Programming Languages and Systems},
  year      = {2009},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {80--94},
  abstract  = {We present an algebraic treatment of exception handlers and, more generally, introduce handlers for other computational effects representable by an algebraic theory. These include nondeterminism, interactive input/output, concurrency, state, time, and their combinations; in all cases the computation monad is the free-model monad of the theory. Each such handler corresponds to a model of the theory for the effects at hand. The handling construct, which applies a handler to a computation, is based on the one introduced by Benton and Kennedy, and is interpreted using the homomorphism induced by the universal property of the free model. This general construct can be used to describe previously unrelated concepts from both theory and practice.},
  isbn      = {978-3-642-00590-9}
}

@inproceedings{10.1145/199448.199528,
  author    = {Liang, Sheng and Hudak, Paul and Jones, Mark},
  title     = {Monad Transformers and Modular Interpreters},
  year      = {1995},
  isbn      = {0897916921},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/199448.199528},
  doi       = {10.1145/199448.199528},
  abstract  = {We show how a set of building blocks can be used to construct programming language interpreters, and present implementations of such building blocks capable of supporting many commonly known features, including simple expressions, three different function call mechanisms (call-by-name, call-by-value and lazy evaluation), references and assignment, nondeterminism, first-class continuations, and program tracing.The underlying mechanism of our system is monad transformers, a simple form of abstraction for introducing a wide range of computational behaviors, such as state, I/O, continuations, and exceptions.Our work is significant in the following respects. First, we have succeeded in designing a fully modular interpreter based on monad transformers that incudes features missing from Steele's, Espinosa's, and Wadler's earlier efforts. Second, we have found new ways to lift monad operations through monad transformers, in particular difficult cases not achieved in Moggi's original work. Third, we have demonstrated that interactions between features are reflected in liftings and that semantics can be changed by reordering monad transformers. Finally, we have implemented our interpreter in Gofer, whose constructor classes provide just the added power over Haskell's type classes to allow precise and convenient expression of our ideas. This implementation includes a method for constructing extensible unions and a form of subtyping that is interesting in its own right.},
  booktitle = {Proceedings of the 22nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {333–343},
  numpages  = {11},
  location  = {San Francisco, California, USA},
  series    = {POPL '95}
}

@inproceedings{10.1145/2633357.2633358,
  author    = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
  title     = {Effect Handlers in Scope},
  year      = {2014},
  isbn      = {9781450330411},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2633357.2633358},
  doi       = {10.1145/2633357.2633358},
  abstract  = {Algebraic effect handlers are a powerful means for describing effectful computations. They provide a lightweight and orthogonal technique to define and compose the syntax and semantics of different effects. The semantics is captured by handlers, which are functions that transform syntax trees.Unfortunately, the approach does not support syntax for scoping constructs, which arise in a number of scenarios. While handlers can be used to provide a limited form of scope, we demonstrate that this approach constrains the possible interactions of effects and rules out some desired semantics.This paper presents two different ways to capture scoped constructs in syntax, and shows how to achieve different semantics by reordering handlers. The first approach expresses scopes using the existing algebraic handlers framework, but has some limitations. The problem is fully solved in the second approach where we introduce higher-order syntax.},
  booktitle = {Proceedings of the 2014 ACM SIGPLAN Symposium on Haskell},
  pages     = {1–12},
  numpages  = {12},
  keywords  = {effect handlers, semantics, Haskell, modularity, syntax, monads},
  location  = {Gothenburg, Sweden},
  series    = {Haskell '14}
}

@article{10.1145/2578854.2503791,
  author     = {Kiselyov, Oleg and Sabry, Amr and Swords, Cameron},
  title      = {Extensible Effects: An Alternative to Monad Transformers},
  year       = {2013},
  issue_date = {December 2013},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {48},
  number     = {12},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2578854.2503791},
  doi        = {10.1145/2578854.2503791},
  abstract   = {We design and implement a library that solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering). Effects arise from interactions between a client and an effect handler (interpreter); interactions may vary throughout the program and dynamically adapt to execution conditions. Existing code that relies on monad transformers may be used with our library with minor changes, gaining efficiency over long monad stacks. In addition, our library has greater expressiveness, allowing for practical idioms that are inefficient, cumbersome, or outright impossible with monad transformers.Our alternative to a monad transformer stack is a single monad, for the coroutine-like communication of a client with its handler. Its type reflects possible requests, i.e., possible effects of a computation. To support arbitrary effects and their combinations, requests are values of an extensible union type, which allows adding and, notably, subtracting summands. Extending and, upon handling, shrinking of the union of possible requests is reflected in its type, yielding a type-and-effect system for Haskell. The library is lightweight, generalizing the extensible exception handling to other effects and accurately tracking them in types.},
  journal    = {SIGPLAN Not.},
  month      = {sep},
  pages      = {59–70},
  numpages   = {12},
  keywords   = {effect interaction, open union, monad, type and effect system, effect handler, monad transformer, coroutine}
}

@inproceedings{extensibleEffects,
  author    = {Kiselyov, Oleg and Sabry, Amr and Swords, Cameron},
  title     = {Extensible Effects: An Alternative to Monad Transformers},
  year      = {2013},
  isbn      = {9781450323833},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2503778.2503791},
  doi       = {10.1145/2503778.2503791},
  booktitle = {Proceedings of the 2013 ACM SIGPLAN Symposium on Haskell},
  pages     = {59–70},
  numpages  = {12},
  keywords  = {type and effect system, effect handler, open union, monad, coroutine, effect interaction, monad transformer},
  location  = {Boston, Massachusetts, USA},
  series    = {Haskell '13}
}

@inproceedings{10.1145/3331545.3342595,
  author    = {Schrijvers, Tom and Pir\'{o}g, Maciej and Wu, Nicolas and Jaskelioff, Mauro},
  title     = {Monad Transformers and Modular Algebraic Effects: What Binds Them Together},
  year      = {2019},
  isbn      = {9781450368131},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3331545.3342595},
  doi       = {10.1145/3331545.3342595},
  abstract  = {For over two decades, monad transformers have been the main modular approach for expressing purely functional side-effects in Haskell. Yet, in recent years algebraic effects have emerged as an alternative whose popularity is growing. While the two approaches have been well-studied, there is still confusion about their relative merits and expressiveness, especially when it comes to their comparative modularity. This paper clarifies the connection between the two approaches—some of which is folklore—and spells out consequences that we believe should be better known. We characterise a class of algebraic effects that is modular, and show how these correspond to a specific class of monad transformers. In particular, we show that our modular algebraic effects gives rise to monad transformers. Moreover, every monad transformer for algebraic operations gives rise to a modular effect handler.},
  booktitle = {Proceedings of the 12th ACM SIGPLAN International Symposium on Haskell},
  pages     = {98–113},
  numpages  = {16},
  keywords  = {Effects, Transformers, Handlers, Monads},
  location  = {Berlin, Germany},
  series    = {Haskell 2019}
}

@article{10.1145/2775050.2633358,
  author     = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
  title      = {Effect Handlers in Scope},
  year       = {2014},
  issue_date = {December 2014},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {49},
  number     = {12},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2775050.2633358},
  doi        = {10.1145/2775050.2633358},
  abstract   = {Algebraic effect handlers are a powerful means for describing effectful computations. They provide a lightweight and orthogonal technique to define and compose the syntax and semantics of different effects. The semantics is captured by handlers, which are functions that transform syntax trees.Unfortunately, the approach does not support syntax for scoping constructs, which arise in a number of scenarios. While handlers can be used to provide a limited form of scope, we demonstrate that this approach constrains the possible interactions of effects and rules out some desired semantics.This paper presents two different ways to capture scoped constructs in syntax, and shows how to achieve different semantics by reordering handlers. The first approach expresses scopes using the existing algebraic handlers framework, but has some limitations. The problem is fully solved in the second approach where we introduce higher-order syntax.},
  journal    = {SIGPLAN Not.},
  month      = {sep},
  pages      = {1–12},
  numpages   = {12},
  keywords   = {semantics, monads, Haskell, effect handlers, modularity, syntax}
}

@article{goldstein2022parsing,
  title     = {Parsing {Randomness}},
  volume    = {6},
  copyright = {All rights reserved},
  url       = {https://doi.org/10.1145/3563291},
  doi       = {10.1145/3563291},
  abstract  = {Random data generators can be thought of as parsers of streams of randomness. This perspective on generators for random data structures is established folklore in the programming languages community, but it has never been formalized, nor have its consequences been deeply explored. We build on the idea of freer monads to develop free generators, which unify parsing and generation using a common structure that makes the relationship between the two concepts precise. Free generators lead naturally to a proof that a monadic generator can be factored into a parser plus a distribution over choice sequences. Free generators also support a notion of derivative, analogous to the familiar Brzozowski derivatives of formal languages, allowing analysis tools to "preview" the effect of a particular generator choice. This gives rise to a novel algorithm for generating data structures satisfying user-specified preconditions.},
  number    = {OOPSLA2},
  urldate   = {2022-11-21},
  journal   = {Proceedings of the ACM on Programming Languages},
  author    = {Goldstein, Harrison and Pierce, Benjamin C.},
  month     = oct,
  year      = {2022},
  keywords  = {read},
  pages     = {128:89--128:113},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/7DHQCBVA/Goldstein and Pierce - 2022 - Parsing randomness.pdf:application/pdf}
}


@inproceedings{10.1145/3471874.3472982,
  author    = {Teegen, Finn and Prott, Kai-Oliver and Bunkenburg, Niels},
  title     = {Haskell⁻¹: Automatic Function Inversion in Haskell},
  year      = {2021},
  isbn      = {9781450386159},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3471874.3472982},
  doi       = {10.1145/3471874.3472982},
  abstract  = {We present an approach for automatic function inversion in Haskell. The inverse functions we generate are based on an extension of Haskell's computational model with non-determinism and free variables. We implement this functional logic extension of Haskell via a monadic lifting of functions and type declarations. Using inverse functions, we additionally show how Haskell's pattern matching can be augmented with support for functional patterns, which enable arbitrarily deep pattern matching in data structures. Finally, we provide a plugin for the Glasgow Haskell Compiler to seamlessly integrate inverses and functional patterns into the language, covering almost all of the Haskell2010 language standard.},
  booktitle = {Proceedings of the 14th ACM SIGPLAN International Symposium on Haskell},
  pages     = {41–55},
  numpages  = {15},
  keywords  = {partial inversion, Haskell, pattern matching, inversion, monadic transformation, GHC plugin},
  location  = {Virtual, Republic of Korea},
  series    = {Haskell 2021}
}

@article{kiselyov2015freer,
  title     = {Freer monads, more extensible effects},
  author    = {Kiselyov, Oleg and Ishii, Hiromi},
  journal   = {ACM SIGPLAN Notices},
  volume    = {50},
  number    = {12},
  pages     = {94--105},
  year      = {2015},
  publisher = {ACM New York, NY, USA}
}

@article{garnock2018recognising,
  title   = {Recognising and generating terms using derivatives of parsing expression grammars},
  author  = {Garnock-Jones, Tony and Eslamimehr, Mahdi and Warth, Alessandro},
  journal = {arXiv preprint arXiv:1801.10490},
  year    = {2018}
}

@article{petvrivcek2009encoding,
  title   = {Encoding monadic computations in C\# using iterators},
  author  = {Pet{\v{r}}{\'\i}{\v{c}}ek, Tom{\'a}{\v{s}}},
  journal = {Proceedings of ITAT},
  year    = {2009}
}

@article{moggi1991notions,
  title     = {Notions of computation and monads},
  author    = {Moggi, Eugenio},
  journal   = {Information and computation},
  volume    = {93},
  number    = {1},
  pages     = {55--92},
  year      = {1991},
  publisher = {Elsevier}
}

@inproceedings{jones1989probabilistic,
  title        = {A probabilistic powerdomain of evaluations},
  author       = {Jones, Claire and Plotkin, Gordon D},
  booktitle    = {Proceedings. Fourth Annual Symposium on Logic in Computer Science},
  pages        = {186--187},
  year         = {1989},
  organization = {IEEE Computer Society}
}

@incollection{giry1982categorical,
  title     = {A categorical approach to probability theory},
  author    = {Giry, Michele},
  booktitle = {Categorical aspects of topology and analysis},
  pages     = {68--85},
  year      = {1982},
  publisher = {Springer}
}

@book{dewey2017automated,
  title     = {Automated Black Box Generation of Structured Inputs for Use in Software Testing},
  author    = {Dewey, Kyle Thomas},
  year      = {2017},
  publisher = {University of California, Santa Barbara}
}

@article{hamlet1994random,
  title     = {Random testing},
  author    = {Hamlet, Richard},
  journal   = {Encyclopedia of software Engineering},
  volume    = {2},
  pages     = {971--978},
  year      = {1994},
  publisher = {Citeseer}
}

@misc{honggfuzz,
  author = {Honggfuzz},
  year   = {2022},
  title  = {Honggfuzz},
  url    = {https://honggfuzz.dev/}
}

@article{kiselyov2005backtracking,
  title     = {Backtracking, interleaving, and terminating monad transformers: (functional pearl)},
  author    = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P and Sabry, Amr},
  journal   = {ACM SIGPLAN Notices},
  volume    = {40},
  number    = {9},
  pages     = {192--203},
  year      = {2005},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{10.1145/3293882.3339002,
  author    = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik},
  title     = {JQF: Coverage-Guided Property-Based Testing in Java},
  year      = {2019},
  isbn      = {9781450362245},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3293882.3339002},
  doi       = {10.1145/3293882.3339002},
  abstract  = {We present JQF, a platform for performing coverage-guided fuzz testing in Java. JQF is designed both for practitioners, who wish to find bugs in Java programs, as well as for researchers, who wish to implement new fuzzing algorithms. Practitioners write QuickCheck-style test methods that take inputs as formal parameters. JQF instruments the test program's bytecode and continuously executes tests using inputs that are generated in a coverage-guided fuzzing loop. JQF's input-generation mechanism is extensible. Researchers can implement custom fuzzing algorithms by extending JQF's Guidance interface. A Guidance instance responds to code coverage events generated during the execution of a test case, such as function calls and conditional jumps, and provides the next input. We describe several guidances that currently ship with JQF, such as: semantic fuzzing with Zest, binary fuzzing with AFL, and complexity fuzzing with PerfFuzz. JQF is a mature tool that is open-source and publicly available. At the time of writing, JQF has been successful in discovering 42 previously unknown bugs in widely used open-source software such as OpenJDK, Apache Commons, and the Google Closure Compiler.},
  booktitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {398–401},
  numpages  = {4},
  keywords  = {QuickCheck, Coverage-guided fuzzing, property-based testing},
  location  = {Beijing, China},
  series    = {ISSTA 2019}
}

@inproceedings{godefroid2008grammar,
  title     = {Grammar-based whitebox fuzzing},
  author    = {Godefroid, Patrice and Kiezun, Adam and Levin, Michael Y},
  booktitle = {Proceedings of the 29th ACM SIGPLAN conference on programming language design and implementation},
  pages     = {206--215},
  year      = {2008}
}

@article{steinhofel2022input,
  title   = {Input Invariants},
  author  = {Steinh{\"o}fel, Dominic and Zeller, Andreas},
  journal = {ESEC/FSE 2022},
  year    = {2022}
}

@inproceedings{sargsyan2018grammar,
  title        = {Grammar-based fuzzing},
  author       = {Sargsyan, Sevak and Kurmangaleev, Shamil and Mehrabyan, Matevos and Mishechkin, Maksim and Ghukasyan, Tsolak and Asryan, Sergey},
  booktitle    = {2018 Ivannikov Memorial Workshop (IVMEM)},
  pages        = {32--35},
  year         = {2018},
  organization = {IEEE}
}

@inproceedings{wang2019superion,
  title        = {Superion: Grammar-aware greybox fuzzing},
  author       = {Wang, Junjie and Chen, Bihuan and Wei, Lei and Liu, Yang},
  booktitle    = {2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)},
  pages        = {724--735},
  year         = {2019},
  organization = {IEEE}
}

@inproceedings{srivastava2021gramatron,
  title     = {Gramatron: Effective grammar-aware fuzzing},
  author    = {Srivastava, Prashast and Payer, Mathias},
  booktitle = {Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {244--256},
  year      = {2021}
}

@inproceedings{eberlein2020evolutionary,
  title        = {Evolutionary grammar-based fuzzing},
  author       = {Eberlein, Martin and Noller, Yannic and Vogel, Thomas and Grunske, Lars},
  booktitle    = {International Symposium on Search Based Software Engineering},
  pages        = {105--120},
  year         = {2020},
  organization = {Springer}
}

@inproceedings{holler2012fuzzing,
  title     = {Fuzzing with code fragments},
  author    = {Holler, Christian and Herzig, Kim and Zeller, Andreas},
  booktitle = {21st USENIX Security Symposium (USENIX Security 12)},
  pages     = {445--458},
  year      = {2012}
}

@inproceedings{veggalam2016ifuzzer,
  title        = {Ifuzzer: An evolutionary interpreter fuzzer using genetic programming},
  author       = {Veggalam, Spandan and Rawat, Sanjay and Haller, Istvan and Bos, Herbert},
  booktitle    = {European Symposium on Research in Computer Security},
  pages        = {581--601},
  year         = {2016},
  organization = {Springer}
}

@book{johnson1975yacc,
  title     = {Yacc: Yet another compiler-compiler},
  author    = {Johnson, Stephen C and others},
  volume    = {32},
  year      = {1975},
  publisher = {Bell Laboratories Murray Hill, NJ}
}

@inproceedings{Bornholt2021,
  author    = {James Bornholt and Rajeev Joshi and Vytautas Astrauskas and Brendan Cully and Bernhard Kragl and Seth Markle and Kyle Sauri and Drew Schleit and Grant Slatton and Serdar Tasiran and Jacob Van Geffen and Andrew Warfield},
  title     = {Using lightweight formal methods to validate a key-value storage node in Amazon S3},
  year      = {2021},
  longurl   = {https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3},
  booktitle = {SOSP 2021}
}

@article{hughes2014mysteries,
  title     = {Mysteries of Dropbox},
  author    = {Hughes, John and Pierce, Benjamin and Arts, Thomas and Norell, Ulf},
  year      = {2014},
  publisher = {Citeseer}
}

@inproceedings{arts2015testing,
  title        = {Testing AUTOSAR software with QuickCheck},
  author       = {Arts, Thomas and Hughes, John and Norell, Ulf and Svensson, Hans},
  booktitle    = {2015 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)},
  pages        = {1--4},
  year         = {2015},
  organization = {IEEE}
}

@incollection{hughes2016experiences,
  title     = {Experiences with QuickCheck: testing the hard stuff and staying sane},
  author    = {Hughes, John},
  booktitle = {A List of Successes That Can Change the World},
  pages     = {169--186},
  year      = {2016},
  publisher = {Springer}
}

@article{blandford2016qualitative,
  title     = {Qualitative HCI research: Going behind the scenes},
  author    = {Blandford, Ann and Furniss, Dominic and Makri, Stephann},
  journal   = {Synthesis lectures on human-centered informatics},
  volume    = {9},
  number    = {1},
  pages     = {1--115},
  year      = {2016},
  publisher = {Morgan \& Claypool Publishers}
}

@audio{signalsandthreads,
  author       = {Yaron Minsky},
  title        = {Signals and Threads},
  howpublished = {Web},
  year         = {2022},
  organization = {Jane Street, LLC},
  url          = {https://signalsandthreads.com/}
}

@article{zeller2002simplifying,
  title     = {Simplifying and isolating failure-inducing input},
  author    = {Zeller, Andreas and Hildebrandt, Ralf},
  journal   = {IEEE Transactions on Software Engineering},
  volume    = {28},
  number    = {2},
  pages     = {183--200},
  year      = {2002},
  publisher = {IEEE}
}

@article{beyer1999contextual,
  title     = {Contextual design},
  author    = {Beyer, Hugh and Holtzblatt, Karen},
  journal   = {interactions},
  volume    = {6},
  number    = {1},
  pages     = {32--42},
  year      = {1999},
  publisher = {ACM New York, NY, USA}
}

@article{nelson2021automated,
  title   = {Automated, Targeted Testing of Property-Based Testing Predicates},
  author  = {Nelson, Tim and Rivera, Elijah and Soucie, Sam and Del Vecchio, Thomas and Wrenn, John and Krishnamurthi, Shriram},
  journal = {arXiv preprint arXiv:2111.10414},
  year    = {2021}
}

@article{wrenn2021using,
  title   = {Using Relational Problems to Teach Property-Based Testing},
  author  = {Wrenn, John and Nelson, Tim and Krishnamurthi, Shriram},
  journal = {The art science and engineering of programming},
  volume  = {5},
  number  = {2},
  year    = {2021}
}

@inproceedings{berghofer2004random,
  title        = {Random Testing in Isabelle/HOL.},
  author       = {Berghofer, Stefan and Nipkow, Tobias},
  booktitle    = {SEFM},
  volume       = {4},
  pages        = {230--239},
  year         = {2004},
  organization = {Citeseer}
}

@article{jackson1996elements,
  title     = {Elements of style: Analyzing a software design feature with a counterexample detector},
  author    = {Jackson, Daniel and Damon, Craig A},
  journal   = {IEEE Transactions on software engineering},
  volume    = {22},
  number    = {7},
  pages     = {484--495},
  year      = {1996},
  publisher = {IEEE}
}

@article{biere2009bounded,
  title   = {Bounded model checking.},
  author  = {Biere, Armin and Cimatti, Alessandro and Clarke, Edmund M and Strichman, Ofer and Zhu, Yunshan},
  journal = {Handbook of satisfiability},
  volume  = {185},
  number  = {99},
  pages   = {457--481},
  year    = {2009}
}

@misc{hatfield-dodds_hypofuzz_nodate,
  title   = {{HypoFuzz}},
  url     = {https://hypofuzz.com/},
  urldate = {2022-12-01},
  journal = {HypoFuzz},
  author  = {Hatfield-Dodds, Zac},
  file    = {HypoFuzz:/Users/harrison/Zotero/storage/CSKNT77U/hypofuzz.com.html:text/html}
}

@inproceedings{fioraldi_afl_2020,
  title      = {\{{AFL}++\} : {Combining} {Incremental} {Steps} of {Fuzzing} {Research}},
  shorttitle = {\{{AFL}++\}},
  url        = {https://www.usenix.org/conference/woot20/presentation/fioraldi},
  language   = {en},
  urldate    = {2022-12-01},
  author     = {Fioraldi, Andrea and Maier, Dominik and Eißfeldt, Heiko and Heuse, Marc},
  year       = {2020},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/LRLUQQQK/Fioraldi et al. - 2020 - AFL++ Combining Incremental Steps of Fuzzing R.pdf:application/pdf;Snapshot:/Users/harrison/Zotero/storage/68IRVCYC/fioraldi.html:text/html}
}

@article{wongsuphasawat_voyager_2016,
  title      = {Voyager: {Exploratory} {Analysis} via {Faceted} {Browsing} of {Visualization} {Recommendations}},
  volume     = {22},
  issn       = {1941-0506},
  shorttitle = {Voyager},
  doi        = {10.1109/TVCG.2015.2467191},
  abstract   = {General visualization tools typically require manual specification of views: analysts must select data variables and then choose which transformations and visual encodings to apply. These decisions often involve both domain and visualization design expertise, and may impose a tedious specification process that impedes exploration. In this paper, we seek to complement manual chart construction with interactive navigation of a gallery of automatically-generated visualizations. We contribute Voyager, a mixed-initiative system that supports faceted browsing of recommended charts chosen according to statistical and perceptual measures. We describe Voyager's architecture, motivating design principles, and methods for generating and interacting with visualization recommendations. In a study comparing Voyager to a manual visualization specification tool, we find that Voyager facilitates exploration of previously unseen data and leads to increased data variable coverage. We then distill design implications for visualization tools, in particular the need to balance rapid exploration and targeted question-answering.},
  number     = {1},
  journal    = {IEEE Transactions on Visualization and Computer Graphics},
  author     = {Wongsuphasawat, Kanit and Moritz, Dominik and Anand, Anushka and Mackinlay, Jock and Howe, Bill and Heer, Jeffrey},
  month      = jan,
  year       = {2016},
  note       = {Conference Name: IEEE Transactions on Visualization and Computer Graphics},
  keywords   = {backlog, active},
  pages      = {649--658},
  file       = {IEEE Xplore Abstract Record:/Users/harrison/Zotero/storage/4XQTC8H8/7192728.html:text/html;Wongsuphasawat et al. - 2016 - Voyager Exploratory Analysis via Faceted Browsing.pdf:/Users/harrison/Zotero/storage/CJVH7AB9/Wongsuphasawat et al. - 2016 - Voyager Exploratory Analysis via Faceted Browsing.pdf:application/pdf}
}

@inproceedings{wongsuphasawat_voyager_2017,
  address    = {Denver Colorado USA},
  title      = {Voyager 2: {Augmenting} {Visual} {Analysis} with {Partial} {View} {Specifications}},
  isbn       = {978-1-4503-4655-9},
  shorttitle = {Voyager 2},
  url        = {https://dl.acm.org/doi/10.1145/3025453.3025768},
  doi        = {10.1145/3025453.3025768},
  abstract   = {Visual data analysis involves both open-ended and focused exploration. Manual chart speciﬁcation tools support question answering, but are often tedious for early-stage exploration where systematic data coverage is needed. Visualization recommenders can encourage broad coverage, but irrelevant suggestions may distract users once they commit to speciﬁc questions. We present Voyager 2, a mixed-initiative system that blends manual and automated chart speciﬁcation to help analysts engage in both open-ended exploration and targeted question answering. We contribute two partial speciﬁcation interfaces: wildcards let users specify multiple charts in parallel, while related views suggest visualizations relevant to the currently speciﬁed chart. We present our interface design and applications of the CompassQL visualization query language to enable these interfaces. In a controlled study we ﬁnd that Voyager 2 leads to increased data ﬁeld coverage compared to a traditional speciﬁcation tool, while still allowing analysts to ﬂexibly drill-down and answer speciﬁc questions.},
  language   = {en},
  urldate    = {2022-11-21},
  booktitle  = {Proceedings of the 2017 {CHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
  publisher  = {ACM},
  author     = {Wongsuphasawat, Kanit and Qu, Zening and Moritz, Dominik and Chang, Riley and Ouk, Felix and Anand, Anushka and Mackinlay, Jock and Howe, Bill and Heer, Jeffrey},
  month      = may,
  year       = {2017},
  keywords   = {backlog},
  pages      = {2648--2659},
  file       = {Wongsuphasawat et al. - 2017 - Voyager 2 Augmenting Visual Analysis with Partial.pdf:/Users/harrison/Zotero/storage/STANYE4Z/Wongsuphasawat et al. - 2017 - Voyager 2 Augmenting Visual Analysis with Partial.pdf:application/pdf}
}


@inproceedings{ellson_graphviz_2002,
  address   = {Berlin, Heidelberg},
  series    = {Lecture {Notes} in {Computer} {Science}},
  title     = {Graphviz— {Open} {Source} {Graph} {Drawing} {Tools}},
  isbn      = {978-3-540-45848-7},
  doi       = {10.1007/3-540-45848-4_57},
  abstract  = {Graphviz is a heterogeneous collection of graph drawing tools containing batch layout programs (dot, neato, fdp, twopi); a platform for incremental layout (Dynagraph); customizable graph editors (dotty, Grappa); a server for including graphs in Web pages (WebDot); support for graphs as COM objects (Montage); utility programs useful in graph visualization; and libraries for attributed graphs. The software is available under an Open Source license. The article[1] provides a detailed description of the package.},
  language  = {en},
  booktitle = {Graph {Drawing}},
  publisher = {Springer},
  author    = {Ellson, John and Gansner, Emden and Koutsofios, Lefteris and North, Stephen C. and Woodhull, Gordon},
  editor    = {Mutzel, Petra and Jünger, Michael and Leipert, Sebastian},
  year      = {2002},
  pages     = {483--484},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/YEPNC8XX/Ellson et al. - 2002 - Graphviz— Open Source Graph Drawing Tools.pdf:application/pdf}
}


@inproceedings{oconnor_quickstrom_2022,
  address    = {New York, NY, USA},
  series     = {{PLDI} 2022},
  title      = {Quickstrom: property-based acceptance testing with {LTL} specifications},
  isbn       = {978-1-4503-9265-5},
  shorttitle = {Quickstrom},
  url        = {https://doi.org/10.1145/3519939.3523728},
  doi        = {10.1145/3519939.3523728},
  abstract   = {We present Quickstrom, a property-based testing system for acceptance testing of interactive applications. Using Quickstrom, programmers can specify the behaviour of web applications as properties in our testing-oriented dialect of Linear Temporal Logic (LTL) called QuickLTL, and then automatically test their application against the given specification with hundreds of automatically generated interactions. QuickLTL extends existing finite variants of LTL for the testing use-case, determining likely outcomes from partial traces whose minimum length is itself determined by the LTL formula. This temporal logic is embedded in our specification language, Specstrom, which is designed to be approachable to web programmers, expressive for writing specifications, and easy to analyse. Because Quickstrom tests only user-facing behaviour, it is agnostic to the implementation language of the system under test. We therefore formally specify and test many implementations of the popular TodoMVC benchmark, used for evaluation and comparison across various web frontend frameworks and languages. Our tests uncovered bugs in almost half of the available implementations.},
  urldate    = {2022-12-04},
  booktitle  = {Proceedings of the 43rd {ACM} {SIGPLAN} {International} {Conference} on {Programming} {Language} {Design} and {Implementation}},
  publisher  = {Association for Computing Machinery},
  author     = {O'Connor, Liam and Wickström, Oskar},
  month      = jun,
  year       = {2022},
  keywords   = {linear temporal logic, property-based testing, web applications},
  pages      = {1025--1038},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/CMXTFMF6/O'Connor and Wickström - 2022 - Quickstrom property-based acceptance testing with.pdf:application/pdf}
}

@incollection{hughes_experiences_2016,
  address    = {Cham},
  series     = {Lecture {Notes} in {Computer} {Science}},
  title      = {Experiences with {QuickCheck}: {Testing} the {Hard} {Stuff} and {Staying} {Sane}},
  isbn       = {978-3-319-30936-1},
  shorttitle = {Experiences with {QuickCheck}},
  url        = {https://doi.org/10.1007/978-3-319-30936-1_9},
  abstract   = {This is not a typical scientific paper. It does not present a new method, with careful experiments to evaluate it, and detailed references to related work. Rather, it recounts some of my experiences over the last 15 years, working with QuickCheck, and its purpose is as much to entertain as to inform.},
  language   = {en},
  urldate    = {2022-12-04},
  booktitle  = {A {List} of {Successes} {That} {Can} {Change} the {World}: {Essays} {Dedicated} to {Philip} {Wadler} on the {Occasion} of {His} 60th {Birthday}},
  publisher  = {Springer International Publishing},
  author     = {Hughes, John},
  editor     = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
  year       = {2016},
  doi        = {10.1007/978-3-319-30936-1_9},
  keywords   = {Controller Area Network, Fail Test Case, Input Index, Race Condition, State Transition Function},
  pages      = {169--186},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/P4CR3FFW/Hughes - 2016 - Experiences with QuickCheck Testing the Hard Stuf.pdf:application/pdf}
}

@article{chasins_pl_2021,
  title      = {{PL} and {HCI}: better together},
  volume     = {64},
  issn       = {0001-0782, 1557-7317},
  shorttitle = {{PL} and {HCI}},
  url        = {https://dl.acm.org/doi/10.1145/3469279},
  doi        = {10.1145/3469279},
  abstract   = {Collaborations between two communities have unearthed a sweet spot for future programming efforts.},
  language   = {en},
  number     = {8},
  urldate    = {2022-12-05},
  journal    = {Communications of the ACM},
  author     = {Chasins, Sarah E. and Glassman, Elena L. and Sunshine, Joshua},
  month      = aug,
  year       = {2021},
  pages      = {98--106},
  file       = {Chasins et al. - 2021 - PL and HCI better together.pdf:/Users/harrison/Zotero/storage/S9C9HTDP/Chasins et al. - 2021 - PL and HCI better together.pdf:application/pdf}
}

@inproceedings{paraskevopoulou_foundational_2015,
  address   = {Cham},
  series    = {Lecture {Notes} in {Computer} {Science}},
  title     = {Foundational {Property}-{Based} {Testing}},
  isbn      = {978-3-319-22102-1},
  doi       = {10.1007/978-3-319-22102-1_22},
  abstract  = {Integrating property-based testing with a proof assistant creates an interesting opportunity: reusable or tricky testing code can be formally verified using the proof assistant itself. In this work we introduce a novel methodology for formally verified property-based testing and implement it as a foundational verification framework for QuickChick, a port of QuickCheck to Coq. Our framework enables one to verify that the executable testing code is testing the right Coq property. To make verification tractable, we provide a systematic way for reasoning about the set of outcomes a random data generator can produce with non-zero probability, while abstracting away from the actual probabilities. Our framework is firmly grounded in a fully verified implementation of QuickChick itself, using the same underlying verification methodology. We also apply this methodology to a complex case study on testing an information-flow control abstract machine, demonstrating that our verification methodology is modular and scalable and that it requires minimal changes to existing code.},
  language  = {en},
  booktitle = {Interactive {Theorem} {Proving}},
  publisher = {Springer International Publishing},
  author    = {Paraskevopoulou, Zoe and Hriţcu, Cătălin and Dénès, Maxime and Lampropoulos, Leonidas and Pierce, Benjamin C.},
  editor    = {Urban, Christian and Zhang, Xingyuan},
  year      = {2015},
  pages     = {325--343},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/JEPHXVET/Paraskevopoulou et al. - 2015 - Foundational Property-Based Testing.pdf:application/pdf}
}

@article{lampropoulos_coverage_2019,
  title    = {Coverage guided, property based testing},
  volume   = {3},
  url      = {https://doi.org/10.1145/3360607},
  doi      = {10.1145/3360607},
  number   = {OOPSLA},
  journal  = {PACMPL},
  author   = {Lampropoulos, Leonidas and Hicks, Michael and Pierce, Benjamin C.},
  year     = {2019},
  keywords = {AFL, coverage, fuzz testing, FuzzChick, property-based testing, QuickChick, random testing},
  pages    = {181:1--181:29},
  file     = {Full Text:/Users/harrison/Zotero/storage/DZM9WCC7/Lampropoulos et al. - 2019 - Coverage guided, property based testing.pdf:application/pdf}
}

@inproceedings{li_model-based_2021,
  address   = {New York, NY, USA},
  series    = {{ISSTA} 2021},
  title     = {Model-based testing of networked applications},
  isbn      = {978-1-4503-8459-9},
  url       = {http://doi.org/10.1145/3460319.3464798},
  doi       = {10.1145/3460319.3464798},
  abstract  = {We present a principled automatic testing framework for application-layer protocols. The key innovation is a domain-specific embedded language for writing nondeterministic models of the behavior of networked servers. These models are defined within the Coq interactive theorem prover, supporting a smooth transition from testing to formal verification. Given a server model, we show how to automatically derive a tester that probes the server for unexpected behaviors. We address the uncertainties caused by both the server's internal choices and the network delaying messages nondeterministically. The derived tester accepts server implementations whose possible behaviors are a subset of those allowed by the nondeterministic model. We demonstrate the effectiveness of this framework by using it to specify and test a fragment of the HTTP/1.1 protocol, showing that the automatically derived tester can capture RFC violations in buggy server implementations, including the latest versions of Apache and Nginx.},
  urldate   = {2022-12-05},
  booktitle = {Proceedings of the 30th {ACM} {SIGSOFT} {International} {Symposium} on {Software} {Testing} and {Analysis}},
  publisher = {Association for Computing Machinery},
  author    = {Li, Yishuai and Pierce, Benjamin C. and Zdancewic, Steve},
  month     = jul,
  year      = {2021},
  keywords  = {Coq, HTTP, interaction trees, Model-based testing, network refinement, nondeterminism},
  pages     = {529--539},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/RETUZJ44/Li et al. - 2021 - Model-based testing of networked applications.pdf:application/pdf}
}

@article{papadakis_mutation_2018,
  title      = {Mutation {Testing} {Advances}: {An} {Analysis} and {Survey}},
  issn       = {0065-2458},
  shorttitle = {Mutation {Testing} {Advances}},
  url        = {http://dx.doi.org/10.1016/bs.adcom.2018.03.015},
  abstract   = {Mutation testing realizes the idea of using artificial defects to support testing activities. Mutation is typically used as a way to evaluate the adequacy of test suites, to guide the generation of test cases, and to support experimentation. Mutation has reached a maturity phase and gradually gains popularity both in academia and in industry. This chapter presents a survey of recent advances, over the past decade, related to the fundamental problems of mutation testing and sets out the challenges and open problems for the future development of the method. It also collects advices on best practices related to the use of mutation in empirical studies of software testing. Thus, giving the reader a “mini-handbook”-style roadmap for the application of mutation testing as experimental methodology.},
  language   = {eng},
  urldate    = {2022-12-07},
  journal    = {Advances in Computers},
  author     = {Papadakis, M. and Kintis, M. and Zhang, J. and Jia, Y. and Traon, Y. L. and Harman, M.},
  month      = jan,
  year       = {2018},
  file       = {Papadakis et al. - 2019 - Mutation Testing Advances An Analysis and Survey.pdf:/Users/harrison/Zotero/storage/BS5GFCDC/Papadakis et al. - 2019 - Mutation Testing Advances An Analysis and Survey.pdf:application/pdf;Snapshot:/Users/harrison/Zotero/storage/8L3MHP95/10056704.html:text/html}
}

@inproceedings{palka_testing_2011,
  address   = {New York, NY, USA},
  series    = {{AST} '11},
  title     = {Testing an optimising compiler by generating random lambda terms},
  isbn      = {978-1-4503-0592-1},
  url       = {http://doi.org/10.1145/1982595.1982615},
  doi       = {10.1145/1982595.1982615},
  abstract  = {This paper considers random testing of a compiler, using randomly generated programs as inputs, and comparing their behaviour with and without optimisation. Since the generated programs must compile, then we need to take into account syntax, scope rules, and type checking during our random generation. Doing so, while attaining a good distribution of test data, proves surprisingly subtle; the main contribution of this paper is a workable solution to this problem. We used it to generate typed functions on lists, which we compiled using the Glasgow Haskell compiler, a mature production quality Haskell compiler. After around 20,000 tests we triggered an optimiser failure, and automatically simplified it to a program with just a few constructs.},
  urldate   = {2022-12-07},
  booktitle = {Proceedings of the 6th {International} {Workshop} on {Automation} of {Software} {Test}},
  publisher = {Association for Computing Machinery},
  author    = {Pałka, Michał H. and Claessen, Koen and Russo, Alejandro and Hughes, John},
  month     = may,
  year      = {2011},
  keywords  = {random testing, software testing},
  pages     = {91--97},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/HYGD66NH/Pałka et al. - 2011 - Testing an optimising compiler by generating rando.pdf:application/pdf}
}

@inproceedings{macqueen_modules_1984,
  address   = {New York, NY, USA},
  series    = {{LFP} '84},
  title     = {Modules for standard {ML}},
  isbn      = {978-0-89791-142-9},
  url       = {http://doi.org/10.1145/800055.802036},
  doi       = {10.1145/800055.802036},
  abstract  = {The functional programming language ML has been undergoing a thorough redesign during the past year, and the module facility described here has been proposed as part of the revised language, now called Standard ML. The design has three main goals: (1) to facilitate the structuring of large ML programs; (2) to support separate compilation and generic library units; and (3) to employ new ideas in the semantics of data types to extend the power of ML's polymorphic type system. It is based on concepts inherent in the structure of ML, primarily the notions of a declaration, its type signature, and the environment that it denotes.},
  urldate   = {2022-12-09},
  booktitle = {Proceedings of the 1984 {ACM} {Symposium} on {LISP} and functional programming},
  publisher = {Association for Computing Machinery},
  author    = {MacQueen, David},
  month     = aug,
  year      = {1984},
  pages     = {198--207},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/DE899WMA/MacQueen - 1984 - Modules for standard ML.pdf:application/pdf}
}

@inproceedings{smith_discovering_2017,
  address   = {Paderborn Germany},
  title     = {Discovering relational specifications},
  isbn      = {978-1-4503-5105-8},
  url       = {https://dl.acm.org/doi/10.1145/3106237.3106279},
  doi       = {10.1145/3106237.3106279},
  abstract  = {Formal specifications of library functions play a critical role in a number of program analysis and development tasks. We present Bach, a technique for discovering likely relational specifications from data describing input–output behavior of a set of functions comprising a library or a program. Relational specifications correlate different executions of different functions; for instance, commutativity, transitivity, equivalence of two functions, etc. Bach combines novel insights from program synthesis and databases to discover a rich array of specifications. We apply Bach to learn specifications from data generated for a number of standard libraries. Our experimental evaluation demonstrates Bach’s ability to learn useful and deep specifications in a small amount of time.},
  language  = {en},
  urldate   = {2022-12-13},
  booktitle = {Proceedings of the 2017 11th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
  publisher = {ACM},
  author    = {Smith, Calvin and Ferns, Gabriel and Albarghouthi, Aws},
  month     = aug,
  year      = {2017},
  keywords  = {Datalog, Hyperproperties, Specification Mining},
  pages     = {616--626},
  file      = {Smith et al. - 2017 - Discovering relational specifications.pdf:/Users/harrison/Zotero/storage/NJZMFAGI/Smith et al. - 2017 - Discovering relational specifications.pdf:application/pdf}
}

@article{hazimeh_magma_2021,
  title      = {Magma: {A} {Ground}-{Truth} {Fuzzing} {Benchmark}},
  volume     = {4},
  shorttitle = {Magma},
  url        = {http://doi.org/10.1145/3428334},
  doi        = {10.1145/3428334},
  abstract   = {High scalability and low running costs have made fuzz testing the de facto standard for discovering software bugs. Fuzzing techniques are constantly being improved in a race to build the ultimate bug-finding tool. However, while fuzzing excels at finding bugs in the wild, evaluating and comparing fuzzer performance is challenging due to the lack of metrics and benchmarks. For example, crash count---perhaps the most commonly-used performance metric---is inaccurate due to imperfections in deduplication techniques. Additionally, the lack of a unified set of targets results in ad hoc evaluations that hinder fair comparison. We tackle these problems by developing Magma, a ground-truth fuzzing benchmark that enables uniform fuzzer evaluation and comparison. By introducing real bugs into real software, Magma allows for the realistic evaluation of fuzzers against a broad set of targets. By instrumenting these bugs, Magma also enables the collection of bug-centric performance metrics independent of the fuzzer. Magma is an open benchmark consisting of seven targets that perform a variety of input manipulations and complex computations, presenting a challenge to state-of-the-art fuzzers. We evaluate seven widely-used mutation-based fuzzers (AFL, AFLFast, AFL++, FairFuzz, MOpt-AFL, honggfuzz, and SymCC-AFL) against Magma over 200,000 CPU-hours. Based on the number of bugs reached, triggered, and detected, we draw conclusions about the fuzzers' exploration and detection capabilities. This provides insight into fuzzer performance evaluation, highlighting the importance of ground truth in performing more accurate and meaningful evaluations.},
  number     = {3},
  urldate    = {2022-12-13},
  journal    = {Proceedings of the ACM on Measurement and Analysis of Computing Systems},
  author     = {Hazimeh, Ahmad and Herrera, Adrian and Payer, Mathias},
  month      = jun,
  year       = {2021},
  keywords   = {benchmark, fuzzing, performance evaluation, software security},
  pages      = {49:1--49:29},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/AJ2ZEM4U/Hazimeh et al. - 2021 - Magma A Ground-Truth Fuzzing Benchmark.pdf:application/pdf}
}

@inproceedings{goldstein_problems_2022,
  title    = {Some {Problems} with {Properties}},
  volume   = {1},
  url      = {https://harrisongoldste.in/papers/hatra2022.pdf},
  language = {en},
  author   = {Goldstein, Harrison and Cutler, Joseph W and Stein, Adam and Pierce, Benjamin C and Head, Andrew},
  month    = dec,
  year     = {2022},
  file     = {Goldstein et al. - Some Problems with Properties.pdf:/Users/harrison/Zotero/storage/QVA4RMQP/Goldstein et al. - Some Problems with Properties.pdf:application/pdf}
}

@misc{dolan_jq_nodate,
  title   = {jq},
  url     = {https://stedolan.github.io/jq/},
  urldate = {2022-12-13},
  journal = {jq},
  author  = {Dolan, Stephen},
  file    = {jq:/Users/harrison/Zotero/storage/4KEMQMIH/jq.html:text/html}
}

@misc{noauthor_when_nodate,
  title      = {({When}) {Will} {Property}-{Based} {Testing} {Rule} the {World}? {\textbar} {SkillsCast}},
  shorttitle = {({When}) {Will} {Property}-{Based} {Testing} {Rule} the {World}?},
  url        = {https://skillsmatter.com/skillscasts/17525-when-will-property-based-testing-rule-the-world},
  abstract   = {YOW! Lambda Jam 2022 conference cast. Benjamin  Pierce:},
  language   = {en},
  urldate    = {2022-12-13},
  journal    = {(When) Will Property-Based Testing Rule the World? {\textbar} SkillsCast},
  file       = {Snapshot:/Users/harrison/Zotero/storage/LANZAVB5/17525-when-will-property-based-testing-rule-the-world.html:text/html}
}

@inproceedings{hughes_quickcheck_2007,
  address   = {Berlin, Heidelberg},
  series    = {Lecture {Notes} in {Computer} {Science}},
  title     = {{QuickCheck} {Testing} for {Fun} and {Profit}},
  isbn      = {978-3-540-69611-7},
  doi       = {10.1007/978-3-540-69611-7_1},
  abstract  = {One of the nice things about purely functional languages is that functions often satisfy simple properties, and enjoy simple algebraic relationships. Indeed, if the functions of an API satisfy elegant laws, that in itself is a sign of a good design—the laws not only indicate conceptual simplicity, but are useful in practice for simplifying programs that use the API, by equational reasoning or otherwise.},
  language  = {en},
  booktitle = {Practical {Aspects} of {Declarative} {Languages}},
  publisher = {Springer},
  author    = {Hughes, John},
  editor    = {Hanus, Michael},
  year      = {2007},
  pages     = {1--32},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/XVTJTA55/Hughes - 2007 - QuickCheck Testing for Fun and Profit.pdf:application/pdf}
}

@inproceedings{arts_shrinking_2014,
  address   = {New York, NY, USA},
  series    = {Erlang '14},
  title     = {On shrinking randomly generated load tests},
  isbn      = {978-1-4503-3038-1},
  url       = {http://doi.org/10.1145/2633448.2633452},
  doi       = {10.1145/2633448.2633452},
  abstract  = {Running a load test is a time consuming undertaking for which normally a complete system should be configured. In contrast to running tests to find deviations from functional requirements, the goal of load testing is to find defects that only appear when the system has a lot of load to handle during a longer time. Load testing is typically performed by increasing the load and observing the effect of doing so. It is plausible that more defects can be detected by a wider variety of scenarios to create load. This makes it an attractive idea to use QuickCheck for the generation of user scenarios to perform load testing with randomly behaving users. In this paper we show that QuickCheck can be used as a framework for doing so by introducing and discussing load generators.},
  urldate   = {2022-12-13},
  booktitle = {Proceedings of the {Thirteenth} {ACM} {SIGPLAN} workshop on {Erlang}},
  publisher = {Association for Computing Machinery},
  author    = {Arts, Thomas},
  month     = sep,
  year      = {2014},
  keywords  = {load testing, model-based testing, property-based testing, quickcheck},
  pages     = {25--31},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/WCBJ4UKK/Arts - 2014 - On shrinking randomly generated load tests.pdf:application/pdf}
}

@article{hou_favonia_logarithm_2022,
  title    = {Logarithm and program testing},
  volume   = {6},
  url      = {http://doi.org/10.1145/3498726},
  doi      = {10.1145/3498726},
  abstract = {Randomized property-based testing has gained much attention recently, but most frameworks stop short at polymorphic properties. Although Bernardy et al. have developed a theory to reduce a wide range of polymorphic properties to monomorphic ones, it relies upon ad-hoc embedding-projection pairs to massage the types into a particular form. This paper skips the embedding-projection pairs and presents a mechanical monomorphization for a general class of polymorphic functions, a step towards automatic testing for polymorphic properties. The calculation of suitable types for monomorphization turns out to be logarithm.},
  number   = {POPL},
  urldate  = {2022-12-14},
  journal  = {Proceedings of the ACM on Programming Languages},
  author   = {Hou (Favonia), Kuen-Bang and Wang, Zhuyang},
  month    = jan,
  year     = {2022},
  keywords = {logarithm, parametricity, polymorphism},
  pages    = {64:1--64:26},
  file     = {Full Text PDF:/Users/harrison/Zotero/storage/UZ5CKUE7/Hou (Favonia) and Wang - 2022 - Logarithm and program testing.pdf:application/pdf}
}

@misc{noauthor_testing_nodate,
  title    = {Testing {Extensions} for {Visual} {Studio} {Code} in {Marketplace}},
  url      = {https://marketplace.visualstudio.com/search?sortBy=Installs&category=Testing&target=VSCode},
  abstract = {Testing extensions for Visual Studio Code on marketplace.visualstudio.com},
  language = {en-US},
  urldate  = {2023-02-16},
  file     = {Snapshot:/Users/harrison/Zotero/storage/ZLZSS5XQ/search.html:text/html}
}

@misc{noauthor_lysxia_nodate,
  title   = {Lysxia - {A} quick tour of generic-random},
  url     = {https://blog.poisson.chat/posts/2018-01-05-generic-random-tour.html},
  urldate = {2023-02-16},
  file    = {Lysxia - A quick tour of generic-random:/Users/harrison/Zotero/storage/9RA2ADBC/2018-01-05-generic-random-tour.html:text/html}
}

@article{feng_program_2018,
  title    = {Program synthesis using conflict-driven learning},
  volume   = {53},
  issn     = {0362-1340},
  url      = {https://doi.org/10.1145/3296979.3192382},
  doi      = {10.1145/3296979.3192382},
  abstract = {We propose a new conflict-driven program synthesis technique that is capable of learning from past mistakes. Given a spurious program that violates the desired specification, our synthesis algorithm identifies the root cause of the conflict and learns new lemmas that can prevent similar mistakes in the future. Specifically, we introduce the notion of equivalence modulo conflict and show how this idea can be used to learn useful lemmas that allow the synthesizer to prune large parts of the search space. We have implemented a general-purpose CDCL-style program synthesizer called Neo and evaluate it in two different application domains, namely data wrangling in R and functional programming over lists. Our experiments demonstrate the substantial benefits of conflict-driven learning and show that Neo outperforms two state-of-the-art synthesis tools, Morpheus and Deepcoder, that target these respective domains.},
  number   = {4},
  urldate  = {2023-02-16},
  journal  = {ACM SIGPLAN Notices},
  author   = {Feng, Yu and Martins, Ruben and Bastani, Osbert and Dillig, Isil},
  month    = jun,
  year     = {2018},
  keywords = {automated reasoning, conflict-driven learning, program synthesis},
  pages    = {420--435},
  file     = {Full Text PDF:/Users/harrison/Zotero/storage/7URT3I7Q/Feng et al. - 2018 - Program synthesis using conflict-driven learning.pdf:application/pdf}
}

@inproceedings{huang_reconciling_2020,
  address   = {New York, NY, USA},
  series    = {{PLDI} 2020},
  title     = {Reconciling enumerative and deductive program synthesis},
  isbn      = {978-1-4503-7613-6},
  url       = {https://doi.org/10.1145/3385412.3386027},
  doi       = {10.1145/3385412.3386027},
  abstract  = {Syntax-guided synthesis (SyGuS) aims to find a program satisfying semantic specification as well as user-provided structural hypotheses. There are two main synthesis approaches: enumerative synthesis, which repeatedly enumerates possible candidate programs and checks their correctness, and deductive synthesis, which leverages a symbolic procedure to construct implementations from specifications. Neither approach is strictly better than the other: automated deductive synthesis is usually very efficient but only works for special grammars or applications; enumerative synthesis is very generally applicable but limited in scalability. In this paper, we propose a cooperative synthesis technique for SyGuS problems with the conditional linear integer arithmetic (CLIA) background theory, as a novel integration of the two approaches, combining the best of the two worlds. The technique exploits several novel divide-and-conquer strategies to split a large synthesis problem to smaller subproblems. The subproblems are solved separately and their solutions are combined to form a final solution. The technique integrates two synthesis engines: a pure deductive component that can efficiently solve some problems, and a height-based enumeration algorithm that can handle arbitrary grammar. We implemented the cooperative synthesis technique, and evaluated it on a wide range of benchmarks. Experiments showed that our technique can solve many challenging synthesis problems not possible before, and tends to be more scalable than state-of-the-art synthesis algorithms.},
  urldate   = {2023-02-16},
  booktitle = {Proceedings of the 41st {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
  publisher = {Association for Computing Machinery},
  author    = {Huang, Kangjing and Qiu, Xiaokang and Shen, Peiyuan and Wang, Yanjun},
  month     = jun,
  year      = {2020},
  keywords  = {deductive synthesis, divide-and-conquer, enumerative synthesis, syntax-guided synthesis},
  pages     = {1159--1174},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/3R6LNDQD/Huang et al. - 2020 - Reconciling enumerative and deductive program synt.pdf:application/pdf}
}

@inproceedings{torlak_growing_2013,
  address   = {New York, NY, USA},
  series    = {Onward! 2013},
  title     = {Growing solver-aided languages with rosette},
  isbn      = {978-1-4503-2472-4},
  url       = {https://doi.org/10.1145/2509578.2509586},
  doi       = {10.1145/2509578.2509586},
  abstract  = {SAT and SMT solvers have automated a spectrum of programming tasks, including program synthesis, code checking, bug localization, program repair, and programming with oracles. In principle, we obtain all these benefits by translating the program (once) to a constraint system understood by the solver. In practice, however, compiling a language to logical formulas is a tricky process, complicated by having to map the solution back to the program level and extend the language with new solver-aided constructs, such as symbolic holes used in synthesis. This paper introduces ROSETTE, a framework for designing solver-aided languages. ROSETTE is realized as a solver-aided language embedded in Racket, from which it inherits extensive support for meta-programming. Our framework frees designers from having to compile their languages to constraints: new languages, and their solver-aided constructs, are defined by shallow (library-based) or deep (interpreter-based) embedding in ROSETTE itself. We describe three case studies, by ourselves and others, of using ROSETTE to implement languages and synthesizers for web scraping, spatial programming, and superoptimization of bitvector programs.},
  urldate   = {2023-02-16},
  booktitle = {Proceedings of the 2013 {ACM} international symposium on {New} ideas, new paradigms, and reflections on programming \& software},
  publisher = {Association for Computing Machinery},
  author    = {Torlak, Emina and Bodik, Rastislav},
  month     = oct,
  year      = {2013},
  keywords  = {solver-aided languages},
  pages     = {135--152},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/MSGK9USA/Torlak and Bodik - 2013 - Growing solver-aided languages with rosette.pdf:application/pdf}
}

@inproceedings{steinhofel_input_2022,
  address   = {New York, NY, USA},
  series    = {{ESEC}/{FSE} 2022},
  title     = {Input invariants},
  isbn      = {978-1-4503-9413-0},
  url       = {https://doi.org/10.1145/3540250.3549139},
  doi       = {10.1145/3540250.3549139},
  abstract  = {How can we generate valid system inputs? Grammar-based fuzzers are highly efficient in producing syntactically valid system inputs. However, programs will often reject inputs that are semantically invalid. We introduce ISLa, a declarative specification language for context-sensitive properties of structured system inputs based on context-free grammars. With ISLa, it is possible to specify input constraints like "a variable has to be defined before it is used," "the 'file name' block must be 100 bytes long," or "the number of columns in all CSV rows must be identical." Such constraints go into the ISLa fuzzer, which leverages the power of solvers like Z3 to solve semantic constraints and, on top, handles quantifiers and predicates over grammar structure. We show that a few ISLa constraints suffice to produce 100\% semantically valid inputs while still maintaining input diversity. ISLa can also parse and precisely validate inputs against semantic constraints. ISLa constraints can be mined from existing input samples. For this, our ISLearn prototype uses a catalog of common patterns, instantiates these over input elements, and retains those candidates that hold for the inputs observed and whose instantiations are fully accepted by input-processing programs. The resulting constraints can then again be used for fuzzing and parsing.},
  urldate   = {2023-02-16},
  booktitle = {Proceedings of the 30th {ACM} {Joint} {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
  publisher = {Association for Computing Machinery},
  author    = {Steinhöfel, Dominic and Zeller, Andreas},
  month     = nov,
  year      = {2022},
  keywords  = {constraint mining, fuzzing, grammars, specification language},
  pages     = {583--594},
  file      = {Full Text PDF:/Users/harrison/Zotero/storage/CQRFYSPF/Steinhöfel and Zeller - 2022 - Input invariants.pdf:application/pdf}
}

@inproceedings{de_moura_z3_2008,
  address    = {Berlin, Heidelberg},
  series     = {Lecture {Notes} in {Computer} {Science}},
  title      = {Z3: {An} {Efficient} {SMT} {Solver}},
  isbn       = {978-3-540-78800-3},
  shorttitle = {Z3},
  doi        = {10.1007/978-3-540-78800-3_24},
  abstract   = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  language   = {en},
  booktitle  = {Tools and {Algorithms} for the {Construction} and {Analysis} of {Systems}},
  publisher  = {Springer},
  author     = {de Moura, Leonardo and Bjørner, Nikolaj},
  editor     = {Ramakrishnan, C. R. and Rehof, Jakob},
  year       = {2008},
  keywords   = {Bound Model Check, Linear Arithmetic, Predicate Abstraction, Symbolic Execution, Theory Solver},
  pages      = {337--340},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/Z5DRYWPD/de Moura and Bjørner - 2008 - Z3 An Efficient SMT Solver.pdf:application/pdf}
}

@misc{noauthor_java_nodate,
  title    = {Java {Programming} - {The} {State} of {Developer} {Ecosystem} in 2020 {Infographic}},
  url      = {https://www.jetbrains.com/lp/devecosystem-2020},
  abstract = {JetBrains is a cutting-edge software vendor specializing in the creation of intelligent development tools, including IntelliJ IDEA – the leading Java IDE, and the Kotlin programming language.},
  language = {en},
  urldate  = {2023-02-18},
  journal  = {JetBrains: Developer Tools for Professionals and Teams},
  file     = {Snapshot:/Users/harrison/Zotero/storage/MWZRSKK9/java.html:text/html}
}

@inproceedings{shi_towards_2023,
  title     = {Towards a {Science} of {Interactive} {Proof} {Reading}},
  abstract  = {Proof assistants such as Coq are powerful tools for formally verifying the correctness of software. We are interested in the process of reading the proofs produced in this mechanized context, with a goal of building tools to reduce sources of friction and misunderstanding. In this paper, we summarize the early steps we have taken to understand the design space of comprehension aids and conduct a pilot study, as well as our future plans for this ongoing research.},
  series    = {Proceedings of the 2023 PLATEAU Workshop},
  booktitle = {PLATEAU 2023},
  language  = {en},
  author    = {Shi, Jessica and Pierce, Benjamin and Head, Andrew},
  year      = {2023},
  url       = {https://jwshi21.github.io/Plateau.pdf}
}

@inproceedings{maciver_test-case_2020,
  address    = {Dagstuhl, Germany},
  series     = {Leibniz {International} {Proceedings} in {Informatics} ({LIPIcs})},
  title      = {Test-{Case} {Reduction} via {Test}-{Case} {Generation}: {Insights} from the {Hypothesis} {Reducer} ({Tool} {Insights} {Paper})},
  volume     = {166},
  isbn       = {978-3-95977-154-2},
  shorttitle = {Test-{Case} {Reduction} via {Test}-{Case} {Generation}},
  url        = {https://drops.dagstuhl.de/opus/volltexte/2020/13170},
  doi        = {10.4230/LIPIcs.ECOOP.2020.13},
  urldate    = {2023-01-02},
  booktitle  = {34th {European} {Conference} on {Object}-{Oriented} {Programming} ({ECOOP} 2020)},
  publisher  = {Schloss Dagstuhl–Leibniz-Zentrum für Informatik},
  author     = {MacIver, David R. and Donaldson, Alastair F.},
  editor     = {Hirschfeld, Robert and Pape, Tobias},
  year       = {2020},
  note       = {ISSN: 1868-8969},
  keywords   = {Software testing, backlog, test-case reduction},
  pages      = {13:1--13:27},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/V4323DN7/MacIver and Donaldson - 2020 - Test-Case Reduction via Test-Case Generation Insi.pdf:application/pdf;Snapshot:/Users/harrison/Zotero/storage/QU25T8W9/13170.html:text/html}
}

@misc{noauthor_python_nodate,
  title    = {Python {Developers} {Survey} 2021 {Results}},
  url      = {https://lp.jetbrains.com/python-developers-survey-2021/},
  abstract = {Official Python Developers Survey 2021 Results by Python Software Foundation and JetBrains: more than 23k responses from more than 200 countries.},
  language = {en},
  urldate  = {2023-02-19},
  journal  = {JetBrains: Developer Tools for Professionals and Teams}
}

@article{coblenz_pliers_2021,
  title      = {{PLIERS}: {A} {Process} that {Integrates} {User}-{Centered} {Methods} into {Programming} {Language} {Design}},
  volume     = {28},
  issn       = {1073-0516},
  shorttitle = {{PLIERS}},
  url        = {https://doi.org/10.1145/3452379},
  doi        = {10.1145/3452379},
  abstract   = {Programming language design requires making many usability-related design decisions. However, existing HCI methods can be impractical to apply to programming languages: languages have high iteration costs, programmers require significant learning time, and user performance has high variance. To address these problems, we adapted both formative and summative HCI methods to make them more suitable for programming language design. We integrated these methods into a new process, PLIERS, for designing programming languages in a user-centered way. We assessed PLIERS by using it to design two new programming languages. Glacier extends Java to enable programmers to express immutability properties effectively and easily. Obsidian is a language for blockchains that includes verification of critical safety properties. Empirical studies showed that the PLIERS process resulted in languages that could be used effectively by many programmers and revealed additional opportunities for language improvement.},
  number     = {4},
  urldate    = {2023-01-27},
  journal    = {ACM Transactions on Computer-Human Interaction},
  author     = {Coblenz, Michael and Kambhatla, Gauri and Koronkevich, Paulette and Wise, Jenna L. and Barnaby, Celeste and Sunshine, Joshua and Aldrich, Jonathan and Myers, Brad A.},
  month      = jul,
  year       = {2021},
  keywords   = {programming language design, Usability of programming languages},
  pages      = {28:1--28:53},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/F3YG4AHW/Coblenz et al. - 2021 - PLIERS A Process that Integrates User-Centered Me.pdf:application/pdf}
}

@article{greenman_little_2022,
  title      = {Little {Tricky} {Logic}: {Misconceptions} in the {Understanding} of {LTL}},
  volume     = {7},
  issn       = {2473-7321},
  shorttitle = {Little {Tricky} {Logic}},
  url        = {https://programming-journal.org/2023/7/7},
  doi        = {10.22152/programming-journal.org/2023/7/7},
  language   = {en},
  number     = {2},
  urldate    = {2023-02-19},
  journal    = {The Art, Science, and Engineering of Programming},
  author     = {Greenman, Ben and Saarinen, Sam and Nelson, Tim and Krishnamurthi, Shriram},
  month      = oct,
  year       = {2022},
  pages      = {7},
  file       = {Greenman et al. - 2022 - Little Tricky Logic Misconceptions in the Underst.pdf:/Users/harrison/Zotero/storage/KS8K8Q7W/Greenman et al. - 2022 - Little Tricky Logic Misconceptions in the Underst.pdf:application/pdf}
}

@article{barr_oracle_2015,
  title      = {The {Oracle} {Problem} in {Software} {Testing}: {A} {Survey}},
  volume     = {41},
  issn       = {1939-3520},
  shorttitle = {The {Oracle} {Problem} in {Software} {Testing}},
  doi        = {10.1109/TSE.2014.2372785},
  abstract   = {Testing involves examining the behaviour of a system in order to discover potential faults. Given an input for a system, the challenge of distinguishing the corresponding desired, correct behaviour from potentially incorrect behavior is called the “test oracle problem”. Test oracle automation is important to remove a current bottleneck that inhibits greater overall test automation. Without test oracle automation, the human has to determine whether observed behaviour is correct. The literature on test oracles has introduced techniques for oracle automation, including modelling, specifications, contract-driven development and metamorphic testing. When none of these is completely adequate, the final source of test oracle information remains the human, who may be aware of informal specifications, expectations, norms and domain specific information that provide informal oracle guidance. All forms of test oracles, even the humble human, involve challenges of reducing cost and increasing benefit. This paper provides a comprehensive survey of current approaches to the test oracle problem and an analysis of trends in this important area of software testing research and practice.},
  number     = {5},
  journal    = {IEEE Transactions on Software Engineering},
  author     = {Barr, Earl T. and Harman, Mark and McMinn, Phil and Shahbaz, Muzammil and Yoo, Shin},
  month      = may,
  year       = {2015},
  note       = {Conference Name: IEEE Transactions on Software Engineering},
  keywords   = {automatic testing, Automatic testing, Automation, Licenses, Market research, Probabilistic logic, Reliability, Software testing, Test oracle, testing formalism, Testing formalism},
  pages      = {507--525},
  file       = {IEEE Xplore Full Text PDF:/Users/harrison/Zotero/storage/Z3XKWJ8B/Barr et al. - 2015 - The Oracle Problem in Software Testing A Survey.pdf:application/pdf}
}

@inproceedings{leino_dafny_2010,
  address    = {Berlin, Heidelberg},
  series     = {Lecture {Notes} in {Computer} {Science}},
  title      = {Dafny: {An} {Automatic} {Program} {Verifier} for {Functional} {Correctness}},
  isbn       = {978-3-642-17511-4},
  shorttitle = {Dafny},
  doi        = {10.1007/978-3-642-17511-4_20},
  abstract   = {Traditionally, the full verification of a program’s functional correctness has been obtained with pen and paper or with interactive proof assistants, whereas only reduced verification tasks, such as extended static checking, have enjoyed the automation offered by satisfiability-modulo-theories (SMT) solvers. More recently, powerful SMT solvers and well-designed program verifiers are starting to break that tradition, thus reducing the effort involved in doing full verification.},
  language   = {en},
  booktitle  = {Logic for {Programming}, {Artificial} {Intelligence}, and {Reasoning}},
  publisher  = {Springer},
  author     = {Leino, K. Rustan M.},
  editor     = {Clarke, Edmund M. and Voronkov, Andrei},
  year       = {2010},
  keywords   = {Automatic Program, Call Graph, Java Modeling Language, Proof Obligation, Separation Logic},
  pages      = {348--370},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/89VWXCPX/Leino - 2010 - Dafny An Automatic Program Verifier for Functiona.pdf:application/pdf}
}

@article{jung_iris_2018,
  title      = {Iris from the ground up: {A} modular foundation for higher-order concurrent separation logic},
  volume     = {28},
  issn       = {0956-7968, 1469-7653},
  shorttitle = {Iris from the ground up},
  url        = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/iris-from-the-ground-up-a-modular-foundation-for-higherorder-concurrent-separation-logic/26301B518CE2C52796BFA12B8BAB5B5F},
  doi        = {10.1017/S0956796818000151},
  abstract   = {Iris is a framework for higher-order concurrent separation logic, which has been implemented in the Coq proof assistant and deployed very effectively in a wide variety of verification projects. Iris was designed with the express goal of simplifying and consolidating the foundations of modern separation logics, but it has evolved over time, and the design and semantic foundations of Iris itself have yet to be fully written down and explained together properly in one place. Here, we attempt to fill this gap, presenting a reasonably complete picture of the latest version of Iris (version 3.1), from first principles and in one coherent narrative.},
  language   = {en},
  urldate    = {2023-02-21},
  journal    = {Journal of Functional Programming},
  author     = {Jung, Ralf and Krebbers, Robbert and Jourdan, Jacques-Henri and Bizjak, Aleš and Birkedal, Lars and Dreyer, Derek},
  year       = {2018},
  note       = {Publisher: Cambridge University Press},
  pages      = {e20},
  file       = {Full Text PDF:/Users/harrison/Zotero/storage/84LI6XHS/Jung et al. - 2018 - Iris from the ground up A modular foundation for .pdf:application/pdf}
}

@misc{minsky_testing_nodate,
  title   = {Testing - {Real} {World} {OCaml}},
  url     = {https://dev.realworldocaml.org/testing.html},
  urldate = {2023-02-21},
  author  = {Minsky, Yaron},
  file    = {Testing - Real World OCaml:/Users/harrison/Zotero/storage/62FMXDZE/testing.html:text/html}
}
